[{"id":0,"href":"/inf1901-teluq/docs/modules/module3/activite-3-1/","title":"Activité 3.1","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":1,"href":"/inf1901-teluq/docs/modules/module4/activite-4-1/","title":"Activité 4.1","section":"Module 4: Les entrées et sorties","content":" "},{"id":2,"href":"/inf1901-teluq/docs/modules/module5/activite-5-1/","title":"Activité 5.1","section":"Module 5. La programmation orientée-objet: héritage et le polymorphisme","content":" "},{"id":3,"href":"/inf1901-teluq/docs/credits/","title":"Le professeur","section":"Docs","content":" Daniel Lemire est professeur d\u0026rsquo;informatique à l\u0026rsquo;Université du Québec (TELUQ). Il est classé dans les 2 % des meilleurs scientifiques (classement Stanford University/Elsevier, 2024). Il fait partie des 1000 programmeurs les plus suivis au monde sur GitHub; GitHub compte plus de 100 millions de développeurs. Il a publié plus de 85 articles de recherche évalués par des pairs. Ses travaux se retrouvent dans de nombreuses bibliothèques standard (.NET, Rust, GCC/glibc++, LLVM/libc, Go, Node.js, etc.) et dans les principaux navigateurs web (Safari, Chrome, etc.). Il est rédacteur de la revue Software : Practice and Experience (Wiley, créée en 1971). En 2020, il a reçu le Prix d\u0026rsquo;excellence 2020 de l\u0026rsquo;Université du Québec pour ses travaux sur l\u0026rsquo;accélération de l\u0026rsquo;analyse JSON. Ses recherches portent notamment sur la programmation haute performance. Il est @lemire sur X et tient un blog hebdomadaire à l\u0026rsquo;adresse https://lemire.me/blog. On peut aussi le trouver sur GitHub.\n"},{"id":4,"href":"/inf1901-teluq/docs/modules/module1/teluq/","title":"Modèle du cours","section":"Module 1: Algorithme et pseudocode","content":" Le modèle de l’Université TÉLUQ # Plusieurs étudiants inscrits au cours INF 1220 en sont en leur premier cours à l’Université TÉLUQ. À la l’Université TÉLUQ, nous offrons un enseignement personnalisé : vous débutez et terminez le cours à une date qui vous convient, vous faites les travaux au sein du cours à votre rythme. Le cours est conçu pour être autoportant : un travail pédagogique substantiel a été fait afin que l’étudiant autonome puisse compléter le cours par lui-même, sans aide. Un professeur ou une personne tutrice est là pour répondre à vos questions lorsque vous êtes devant une impasse après avoir fait les lectures et vos recherches, à tous les moments de votre parcours. Ce modèle diffère de celui des Universités traditionnelles où il y a de rencontres de groupe hebdomadaires et où tous les étudiants cheminent en même temps. Les deux modèles ont des forces et des faiblesses. L’Université TÉLUQ offre plus de flexibilité, mais son modèle exige plus d’autonomie intellectuelle de la part des étudiants.\nMener à terme un cours à l’Université TÉLUQ exige de la persévérance et de la motivation, ainsi que de l’autonomie et de la discipline. En vous inscrivant à un cours à distance, vous adoptez un modèle différent de celui d’un cours sur campus. Vous devez organiser votre apprentissage de manière autonome, en utilisant les ressources didactiques et d’encadrement mises à votre disposition, à l’endroit et au moment de votre choix.\nLe professeur est préoccupé par le fait que l’apprentissage s’effectue de façon autonome. Tout le cours est créé en fonction de cet objectif. Dans ce cours, il n’y a donc pas de vidéoconférences. Nous adorons lire vos questions et y répondre, mais vous avez la responsabilité de faire au préalable les exercices et les lectures, ainsi que vos propres recherches. Nous croyons que le résultat est une formation de qualité axée sur l’autonomie et l’indépendance d’esprit.\nApprentissage par vidéo # Certains étudiants préfèrent lire, d\u0026rsquo;autres préfèrent regarder des vidéos. Nous croyons que les deux modes de diffusion (écrit et vidéo) ont leur place en enseignement.\nL’Université TÉLUQ est un précurseur dans l’enseignement avec la vidéo, comme le suggère son nom (télé-université). Longtemps, lors de l’inscription à un cours, on pouvait recevoir des cassettes vidéos (VHS). L’Université TÉLUQ a même porté son propre poste de télévision appelé Canal Savoir.\nQuelques cours à l’Université TÉLUQ sont toujours diffusés principalement avec des vidéos. Dans la plupart des cas, cependant, les cours utilisent des notes de cours. C’est le cas du cours INF 1220. Le langage écrit a plusieurs avantages, notamment le fait d’être plus accessible.\nUn texte peut être lu rapidement. S’il est possible de modifier la vitesse de diffusion d’une vidéo, il demeure plus difficile de faire rapidement des sauts et des retours. Il est relativement aisé de faire des recherches dans un document écrit, et plus difficile dans une vidéo.\nDans le cas du cours INF 1220, l’utilisation plus intensive de la vidéo n’est pas jugée souhaitable pour deux raisons outre l’accessibilité. Tout d’abord, il existe un grand éventail de vidéos de grande qualité déjà disponibles et répondant bien au besoin du cours. Nous jugeons qu’il n’y aurait pas de sens à produire du contenu redondant. Dans certains cas spécifiques, nous avons produit des vidéos, mais dans l’ensemble, il est préférable de renvoyer les étudiants qui souhaitent du contenu vidéo à ce qui est déjà en place. Par ailleurs, avec des décennies d’expérience en pédagogie universitaire, nous savons que l’utilisation à grand volume de la vidéo a des limites. Nous croyons qu’il est beaucoup plus utile d’amener les étudiants à programmer le plus possible, tout en se référant à du contenu écrit. Personne n’apprend vraiment à programmer en regardant des vidéos. On apprend à programmer en lisant du code et en programmant. Et il est difficile de faire des recherches techniques au sein d’un enregistrement vidéo.\nCertains étudiants préfèrent écouter et regarder plutôt que de lire. Nous sommes conscients que la lecture d’un manuel portant sur la programmation peut sembler rébarbative. Par contre, la lecture technique fait partie intégrante de l’activité de programmation. Il est absolument essentiel de pouvoir lire des documents techniques et des descriptions formelles. En somme, si la vidéo peut être utilisée, elle ne peut remplacer la lecture en programmation.\nApplications, jeux, web, etc. # Le cours se veut une introduction à la programmation. Il n’est donc pas question de programmer des jeux vidéo complets, de créer des applications qui pourraient être déployées dans votre organisation, de créer des applications web complètes ou des applications mobiles pouvant être distribuées. Notre objectif n’est que de vous donner les bases vous permettant, dans une seconde étape, de réaliser de tels travaux.\nAvant de maîtriser les interfaces graphiques et le web, il faut d’abord maîtriser la base. Il faut savoir comment manipuler des données en mémoire au sein de scénarios simplifiés avant de résoudre des problèmes réels.\nPython, JavaScript, C#, C++, Go, Rust, etc. # Certains étudiants souhaitent apprendre un autre langage que Java. Nous vous encourageons à étudier plus d’un langage de programmation, surtout si vous souhaitez faire carrière en informatique. Dans le cadre de ce cours, nous allons cibler un seul langage.\nCertains étudiants souhaitent apprendre le C#. Il est particulièrement facile de passer du Java au C#. En effet, le C# peut être vu comme une variante du Java. La syntaxe est souvent quasiment identique et les pratiques de programmation sont équivalentes.\nDans le cadre d’une carrière dans l’industrie du logiciel, il peut être dommage de se limiter à une seule technologie, un seul langage de programmation. Les choix technologiques évoluent et les offres d’emploi diffèrent d’un moment à l’autre. On s’attend à ce qu’un diplômé universitaire maîtrise plusieurs technologies, plusieurs langages.\nSoyez informé ! # Si ce n’est pas déjà fait, prenez le temps de lire la description du cours sur le site web de la TÉLUQ. Vous y trouverez notamment la grille d’équivalence entre les notes numériques et les lettres. Une telle grille répond notamment à la question « quelle est la note de passage ». Observez bien cependant que la note de passage n’est pas suffisante généralement pour progresser normalement au sein d’un programme universitaire et obtenir un diplôme.\nNous vous rappelons que lorsque vous suivez un cours, vous devez lire les courriels de l’Université. L’information pertinente concernant le cours, votre inscription, etc. peut y être acheminée. Si vous ne prenez pas vos messages dans votre boîte courriel TÉLUQ, il peut vous manquer des informations importantes.\nImportant: En commençant, prenez en note la date de fin de cours. Vous devez avoir remis les travaux d’ici cette date. Si vous avez besoin d’un report de la date de fin de cours, peut-être à cause d’empêchements médicaux ou familiaux, vous devez joindre l’Université (pas le professeur) pour établir votre situation et obtenir un report. Vous ne pouvez pas obtenir un report après la date de fin de cours. En aucun cas est-ce que le professeur peut modifier votre date de fin de cours.\nVotre date de fin de cours est inscrite dans votre dossier et vous pouvez la trouver sur le portail étudiant et sur la documentation qu’on vous a remise lors de votre inscription. Il est possible que votre examen ait lieu des semaines ou même des mois après votre date de fin de cours: cela ne constitue pas une extension de votre date de fin de cours. Tout travail remis après votre date de fin de cours pourra recevoir la note de zéro. En tout temps, la note « incomplet » peut être attribuée à un travail qui n’est pas remis après votre date de fin de cours, même si vous n’avez pas encore passé l’examen.\nVous ne devriez jamais avoir à nous demander jusqu’à quelle heure précise lors de la dernière journée de votre cours vous avez pour compléter vos travaux. Prenez le temps de planifier votre travail. Avec la possibilité de report et la flexibilité offerte par la TÉLUQ, il n’y a pas d’excuse pour terminer le cours à la dernière heure.\nLes reports de la date de fin de cours # À la TÉLUQ, chaque étudiant a sa propre date de fin de cours. Les professeurs ne peuvent pas modifier ces dates, quelle que soit votre situation. Les dates des examens sont fixées par l\u0026rsquo;Université. Les professeurs conçoivent les examens, mais leur déroulement est géré par l\u0026rsquo;Université. La période suivant la date de fin de cours, où votre dossier est fermé et où vous risquez de recevoir un incomplet, est également gérée par l\u0026rsquo;Université. Vous devez donc contacter l\u0026rsquo;Université si vous avez besoin de plus de temps. Il est inutile d\u0026rsquo;écrire aux professeurs à ce sujet.\nIl est de votre responsabilité de respecter les délais et de réaliser les travaux selon l\u0026rsquo;échéancier prévu dans le cours. En cas de difficultés (familiales, médicales, situation de handicap), vous devez en informer l\u0026rsquo;Université, et non le professeur. Sinon, une bonne organisation est essentielle.\nLa gestion efficace de votre temps est une compétence clé pour réussir vos études universitaires. Le cours est conçu pour vous y aider en structurant les activités en modules avec des échéances suggérées. Toutefois, c\u0026rsquo;est à vous de vous organiser.\nPlanifier votre temps # Le niveau de difficulté du cours augmente progressivement. Les premiers travaux sont plus accessibles, mais environ un tiers du cours devrait être consacré aux deux derniers modules, qui sont plus avancés. Si vous passez trop de temps sur les lectures et les travaux initiaux, vous pourriez être surpris par la difficulté et le volume de travail des dernières parties.\nExigences du cours # Le cours INF 1220 n\u0026rsquo;est pas un cours facile.\nDans certaines disciplines, lire suffit pour préparer les travaux. En programmation, la lecture seule est insuffisante. Un manuel ne vous apprendra pas à programmer. Vous devez lire, faire des exercices, relire, et répéter ce processus. Apprendre à programmer demande du travail et de la persévérance. La présence de nombreux travaux dans le cours vise à vous encourager à travailler régulièrement et à pratiquer.\nPrévoyez environ 9 heures de travail par semaine pendant 15 semaines pour réussir ce cours. Chaque travail noté demande plusieurs heures, tout comme la préparation et l\u0026rsquo;étude préalables. Il est normal de consacrer des dizaines d\u0026rsquo;heures pour compléter un module et son travail noté. Si vous n\u0026rsquo;avez pas entre 5 et 15 heures par semaine à consacrer au cours, vous risquez de ne pas réussir.\nLe cours inclut des lectures et des activités d\u0026rsquo;autoévaluation (par exemple, des problèmes avec solutions cachées). Vous devez obligatoirement réaliser ces lectures et activités avant les travaux notés. Des vidéos explicatives sont également disponibles : visionnez-les et revisionnez-les au besoin. Tenter de passer directement aux travaux notés sans préparation est voué à l\u0026rsquo;échec. Faire uniquement le minimum pour compléter les travaux notés ne suffira pas pour réussir l\u0026rsquo;examen. Vous devez pratiquer la programmation, apprendre à penser comme un programmeur et maîtriser le Java grâce à une étude rigoureuse.\nSi un travail noté exige d\u0026rsquo;expliquer votre solution, cette consigne est impérative. Ne pas la respecter peut entraîner une note de zéro.\nVotre code doit être fonctionnel et valide, sinon une note de zéro peut être attribuée. La réussite de ce cours repose sur votre capacité à programmer.\nIl est fortement recommandé de faire des recherches autonomes en ligne (YouTube, etc.) pour compléter le manuel, les notes de cours et les activités. La recherche en ligne est une composante essentielle du développement logiciel aujourd\u0026rsquo;hui. Prévoyez plusieurs heures pour explorer des ressources complémentaires selon vos besoins.\nNe débutez pas ce cours si vous n'avez pas les préalables mathématiques nécessaires.\nLe cours INF 1220 a été développé en prenant pour acquis que vous avez fait les mathématiques avancées au secondaire et au collégial. Il fait partie d'un cursus en informatique de niveau universitaire. Si vous n'étiez pas « fort en math » au secondaire, il est possible que vous trouviez le cours trop difficile. Il est de votre responsabilité de faire une mise à niveau au besoin avant de débuter le cours INF 1220.\nNavigateur web Vous pouvez suivre ce cours avec pratiquement n'importe quel navigateur web. Par contre, pour que les formules mathématiques s'affichent correctement, vous devez utiliser un navigateur supportant la norme MathML. Les navigateurs Firefox et Safari font bien l'affaire.\nIl y a peu de formules mathématiques dans ce cours, et il est donc parfaitement possible de travailler sans un support correct des formules mathématiques. Par contre, si vous avez besoin de bien suivre nos consignes et rappels mathématiques, vous devriez sans doute adopter, au moins temporairement, un des navigateurs supportant MathML (par ex., Firefox et Safari).\nEncadrement et suivi Prenez connaissance de la documentation fournie par l'université. Vous y trouverez le nom et l'adresse courriel de la personne qui vous encadre. Après avoir fait les lectures, vous pouvez écrire vos questions à cette personne. Assurez-vous de respecter les consignes énoncées dans la présentation du cours : vous devez mettre « [INF1220] » dans l'objet du courriel et vous devez utiliser une adresse de courriel à votre nom afin que nous puissions vous identifier. Vos courriels devraient comprendre des questions précises, bien détaillées. Vous devriez commencer expliquer ce que vous avez fait, ce que vous comprenez. Il peut être utile de faire référence aux lectures que vous avez faites. N'oubliez pas que les lectures au sein du manuel sont obligatoires. Par exemple, si vous avez du mal avec une notion couverte par le manuel, vous devriez faire une référence à cette section. N'hésitez pas à joindre des saisies d'écran pour illustrer vos propos. Nous nous ferons un plaisir de répondre à vos questions par courriel, mais tel qu'expliqué dans la présentation du cours, nous n’offrons pas d’enseignement par vidéoconférence au sein du cours INF 1220. Réseaux sociaux Attention: Il est strictement défendu de demander des indices aux autres étudiants du cours concernant les travaux notés et l'examen. Il est aussi défendu de donner des indices concernant les travaux notés.\nPlagiat Nous mettons bien entendu à jour les travaux notés et les examens. Dans le cas des travaux notés, vous pouvez toujours remettre la version que vous avez débutée sans pénalité dans le cas où les travaux sont mis à jour pendant votre travail. Par contre, soyez avisé que nous portons une attention particulière au plagiat. Si votre travail ressemble trop à un autre travail remis, nous pourrons alors procéder à un examen oral, pour vérifier si vous avez effectivement fait le travail par vous-même. Dans le cas des examens, nous tentons de les offrir en présence avec surveillance. Quand ce n'est pas possible, nous varions autant que possible le contenu des examens et nous utilisons d'autres mesures à notre disposition pour contrer le plagiat.\nLe plagiat peut avoir des conséquences sévères. Une note permanente peut être ajoutée à votre dossier et à votre relevé de notes. Le plagiat peut mener à votre exclusion du programme universitaire où vous avez été admis.\n"},{"id":5,"href":"/inf1901-teluq/docs/modules/module1/","title":"Module 1: Algorithme et pseudocode","section":"Modules","content":" Module 1 # Un algorithme est une méthode structurée composée d\u0026rsquo;une série d\u0026rsquo;instructions précises destinées à résoudre un problème ou à réaliser une tâche. À l’image d’une recette de cuisine, il repose sur des étapes ordonnées de manière logique pour aboutir à un résultat attendu, comme un plat préparé. Dans ce module, nous explorerons la conception d’algorithmes simples et leur transcription en pseudocode, un langage clair et accessible qui permet de décrire ces étapes sans recourir à la syntaxe d’un langage de programmation spécifique.\nL’objectif de ce module est de vous familiariser avec les fondamentaux des algorithmes et leur importance en informatique. Vous apprendrez à reconnaître leurs composants essentiels, tels que les entrées, les sorties et les instructions, tout en développant la capacité à rédiger des algorithmes simples en pseudocode en français. À travers des exemples concrets tirés du quotidien, vous serez en mesure d’appliquer ces concepts pour résoudre des problèmes pratiques de manière efficace.\n"},{"id":6,"href":"/inf1901-teluq/docs/modules/module2/preparation/","title":"Préparation de l’espace de travail","section":"Module 2: Introduction à l'apprentissage machine","content":"Module 2Activité 2.1Préparation de l'espace de travailSommaire\nUtilisation d'un environnement de programmation en ligne Installation du Java Development Kit (JDK) Utilisation d'un éditeur de texte Installation de l'IDE IntelliJ IDEA Installation de l'IDE Netbeans Installation de l'IDE Eclipse Qu'est-ce que le professeur utilise? Comme langage de support à l'introduction des concepts de programmation, nous utiliserons le langage Java. Tel que présenté dans l'introduction du cours, le langage Java est un langage interprété multi-plateforme où le code est pré-compilé dans un ensemble d'instructions intermédiaires (appelé Java bytecode), puis interprété sur chaque système d'exploitation à partir de la machine virtuelle Java. Celle-ci transforme alors le bytecode en instructions machine propre au système d'exploitation et aux processeurs spécifiques de l'ordinateur.\nSi ce n'est pas déjà fait, il est maintenant temps de configurer un environnement de développement Java. Dans ce cours, vous pouvez utiliser l'environnement de programmation qui vous convient le mieux ou qui fonctionne bien pour vous. Vous n'avez pas à utiliser une approche spécifique.\nDans ce cours vous devez faire preuve d'un minimum de débrouillardise. En particulier, vous devez être à même de choisir l'environnement qui vous convient le mieux. Cette démarche d'appropriation fait partie intégrante du cours. Nous n'offrons pas de soutien technique concernant les outils logiciels que vous choisissez d'installer sur vos ordinateurs. Nous vous invitons à procéder par essai/erreur et à faire les recherches nécessaires.\nQuand vous testez un nouvel environnement, utilisez du code Java simple et bien testé. Si vous ne connaissez pas bien le Java, ne commencez pas à expérimenter avec la programmation tout en testant un nouvel environnement. Allez-y une étape à la fois.\nUtilisation d'un environnement de programmation en ligne Plusieurs étudiants préfèrent un environnement de développement conventionnel, installé sur leur PC. D'autres étudiants peuvent avoir une préférence pour les environnements en ligne qui ne nécessitent aucune installation. Il y a plusieurs environnements en ligne, nous vous invitons à les explorer, en commençant par les suggestions suivantes :\nrepl.it ideone Ces outils en ligne vous permettent de saisir votre code, dans le navigateur, et de l'exécuter par la suite. Vous pouvez faire une grande partie du cours en utilisant seulement un outil comme repl.it. En effet, le cours se concentre principalement sur la programmation. Les outils d'aide à la programmation sont moins importants. Nous ne ferons pas de grands projets dans ce cours qui nécessitent beaucoup de gestion de code.\nLa vidéo suivante illustre l'utilisation de repl.it (il n'est pas nécessaire d'écouter la narration en anglais pour comprendre): Truc: Avec repl.it, vous pouvez ouvrir une console avec les touches ctrl-shift-s où vous pouvez exécuter des commandes comme « javac Main.java » et « java Main ».\nDans le cours, vous trouverez des exemples utilisant repl.it, mais l'utilisation de repl.it est optionnelle. Si repl.it ne fonctionne pas bien pour vous, utilisez autre chose.\nUne des limites d'un environnement comme repl.it est qu'ils ne permettent pas la production d'interfaces graphiques. Ainsi, certains exemples ne peuvent fonctionner sous repl.it.\nNotez bien: Certains des exemples repl.it comprennent plusieurs fichiers. Comme dans plusieurs interfaces, repl.it ne permet de voir le contenu que d'un seul fichier à la fois. Par contre, il vous permet de naviguer entre différents fichiers. Nous verrons dans ce cours que Java exige que les \"classes\" soient définies au sein de fichiers du même nom, ce qui implique souvent que nous utilisions plusieurs fichiers avec des noms prédéterminés. Cette contrainte en ce qui a trait aux fichiers n'est pas spécifique à repl.it. En Java, il y a un lien direct entre le nom des fichiers et leur contenu. Dans ce cours, vous devez faire preuve de débrouillardise et nous supposons que vous trouverez comment faire pour naviguer et voir les différents fichiers. Instructions détaillées pour Repl.it Repl.it est une plateforme en ligne qui permet d’écrire, d’exécuter et de tester du code Java directement dans votre navigateur, sans avoir besoin d’installer un environnement de développement sur votre ordinateur. Pour commencer, accédez aux liens Repl.it fournis dans le cours. Cliquez sur un lien pour ouvrir le projet Java correspondant. Vous verrez une interface avec un éditeur de code à gauche, où le code est déjà chargé, et une console à droite pour afficher les résultats. Si vous n’êtes pas encore inscrit, créez un compte gratuit sur Repl.it en utilisant votre adresse e-mail ou un compte Google. Une fois connecté, vous pouvez modifier le code directement dans l’éditeur. Pour exécuter votre programme, cliquez sur le bouton vert « Run » en haut de la page. La console affichera les sorties ou les erreurs, ce qui vous permettra de vérifier si votre code fonctionne comme prévu.\nPour travailler efficacement sur Repl.it, familiarisez-vous avec ses fonctionnalités principales. Vous pouvez créer un nouveau fichier ou répertoire dans votre projet en cliquant sur l’icône « + » dans la barre latérale. Si vous modifiez le code fourni dans les liens du cours, assurez-vous de ne pas écraser les instructions ou les parties essentielles sans les comprendre. Avec un peu de pratique, Repl.it deviendra un outil puissant et intuitif pour développer vos compétences en programmation Java.\nInstallation du Java Development Kit (JDK) Système d'exploitation Microsoft Windows : Je vous suggère d'installer le JDK à partir du site https://adoptium.net/. La vidéo suivante illustre comment y arriver sous Windows en moins de deux minutes: Aller sur le site https://adoptium.net/. La version a peu d'importance; choisir la dernière version disponible. Une fois le fichier d'installation téléchargé, démarrer l'installation et suivre les différentes étapes d'installation. Une fois le logiciel installé, la machine virtuelle Java (java.exe) et ses outils de compilation (javac.exe) auront été installés. macosNous vous suggérons d'utiliser https://adoptium.net/ encore une fois.\nLinux Debian Si vous êtes un utilisateur de Linux et plus particulièrement de Debian (ou Ubuntu), vous savez probablement déjà utiliser les Debian Packages! Pour installer la JDK, il faut ouvrir l'invite de commande (la console...), se mettre en mode super-utilisateur (su) et exécuter la commande « apt-get install default-jdk ».\nUtilisation d'un éditeur de texte La plupart des langages de programmation s'utilisent avec des fichiers de texte. Le fichier n'est qu'une séquence de caractères sans autre structure particulière. L'outil le plus simple en programmation est donc le simple éditeur de texte. Comme le nom l'indique, l'éditeur de texte vise principalement à éditer des fichiers de texte. Notons que les traitements de texte (comme Word) ne sont pas fait pour éditer des fichiers de texte. Par ailleurs, un éditeur de texte ne peut pas, par lui-même, compiler et exécuter des programmes. Il sert surtout à écrire le code.\nLe meilleur éditeur de fichier texte est sans doute Visual Studio Code (à ne pas confondre avec Visual Studio). Microsoft rend disponible un guide d'utilisation de Visual Studio Code avec java.\nNous recommandons Visual Studio Code plutôt que l'utilisation d'un environnement comme IDEA, Eclipse ou NetBeans. L'utilisation d'un éditeur de texte combiné avec le JDK vous met davantage en charge du développement.\nInstallation de l'IDE IntelliJ IDEA Lecture suggérée : Environnement de développement\nVous pouvez installer l'IDE IntelliJ IDEA. L'utilisation d'un IDE n'est pas obligatoire, mais cela est recommandé. IntelliJ IDEA est un excellent choix.\nRendez-vous sur https://www.jetbrains.com/idea/. Cliquez sur Download. Sous \"Community\", cliquez sur Download. Cette version est gratuite. L'enregistrement du programme d'installation devrait débuter. Suivez ensuite les consignes. Nous croyons que IntelliJ IDEA est supérieur aux autres IDE, étant plus élégant et convivial. Cependant, le choix vous appartient.\nNotez que nous n'offrons pas de soutien technique pour les IDE dans ce cours. Si vous optez pour IntelliJ IDEA, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit. Nous sommes là pour vous appuyer dans l'apprentissage de la programmation et du Java, mais pas dans l'utilisation d'un IDE spécifique.\nLes IDE ont la fâcheuse habitude d'automatiser plusieurs opérations ce qui ne pose pas de problème aux programmeurs expérimentés, mais qui est souvent déroutant pour les débutants. Les IDE vont souvent créer des répertoires, des « paquetages » et avoir différentes attentes quant à l'endroit où les différentes fonctions et classes doivent être. Le résultat net est que les étudiants sont souvent confrontés à des messages d'erreur qui les laissent perplexes après des modifications faites en utilisant l'interface graphique (par exemple, après le déplacement d'un fichier). Si vous utilisez un IDE, il faut apprendre à travailler selon les attentes de l'IDE. À terme, certains programmeurs trouvent que l'utilisation d'un IDE les rend plus productifs, mais quand on débute, l'IDE est un obstacle supplémentaire pour certains étudiants.\nInstallation de l'IDE Netbeans Si vous avez installé IntelliJ IDEA, il n'est sans doute pas nécessaire d'installer aussi Netbeans. Cependant, vous pouvez installer les deux, pour comparer.\nCet IDE possède un éditeur visuel bien fait, stable et complet. Pour installer Netbeans (lors de la dernière mise à jour du cours, il s'agissait de la version Apache Netbeans 11; Depuis Janvier 2019, la gestion du projet Netbeans a passé de Oracle vers l'organisation Apache, vous pouvez utiliser les versions plus récentes sous Apache ainsi que la dernière version d'Oracle 8.2), vous devez suivre les étapes suivantes :\nSuivre le lien suivant: https://netbeans.apache.org/download/index.htmlTélécharger la version \"binaries\" (déjà compilée).Une fois le fichier .zip téléchargé, veuillez le décompresser dans un répertoire personnel. Ouvrez le répertoire ./netbeans/bin, les exécutables pour lancer Netbeans s'y trouvent.Vous pouvez démarrer maintenant Netbeans. Au démarrage, vous pouvez spécifier dans quel répertoire vous voulez que vos projets de programmation soient « sauvegardés ». Par défaut, il s'agit de « C:\\Users\\VotreNomUtilisateur\\Documents\\NetBeansProjects ». Si vous optez pour NetBeans, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit.\nInstallation de l'IDE Eclipse Si vous avez installé IntelliJ IDEA ou Netbeans, il n'est sans doute pas nécessaire d'installer aussi Eclipse. Cependant, vous pouvez installer les trois, pour comparer.\nRendez-vous sur http://www.eclipse.org. Cliquez sur Download. Il peut être nécessaire de cliquer sur Download à plus d'une reprise, alors que différentes pages sont chargées. L'enregistrement du programme d'installation devrait débuter. Suivez ensuite les consignes. [embed width=\u0026ldquo;600\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;]https://www.youtube.com/embed/3vhLoQZOEzU[/embed]\nSi vous optez pour Eclipse, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit.\nErreurs et avertissements Java pourra émettre certains messages lors de la compilation et de l'exécution de vos programmes. Il y a d'une part les messages d'erreur. Dans un tel cas, le programme ne peut être compilé ou exécuté. Il y a d'autre part les messages d'avertissement. Le plus souvent, on peut ignorer les messages d'avertissement. Ils servent avant tout à attirer l'attention du programmeur sur des problèmes potentiels, mais ils ne nuisent pas à la compilation et à l'exécution.\nIl est important de faire la différence entre une erreur et un avertissement. Vous ne devez pas confondre les deux concepts lorsque vous programmez. Soyez précis!\nLes choix du professeur Le cours INF 1220 est développé en utilisant en grande partie repl.it. Bien que l'outil ne soit pas parfait, le fait de pouvoir travailler à partir de n'importe quelle machine dotée d'un navigateur web, sans rien à configurer, est vraiment génial. Par ailleurs, l'aisance avec laquelle on peut partager du code fonctionnel est vraiment géniale. Par ailleurs, s'il faut que je développe du code plus substantiel, j'utilise Visual Studio Code. Je suis actif au sein de plusieurs projets et Visual Studio Code a plusieurs avantages. Il fonctionne pratiquement partout. Visual Studio Code me permet de \"programmer\" dans une multitude de langages, de LaTeX à Go en passant par Haskell, Markdown, C++, etc. Je peux facilement combiner Visual Studio Code a plusieurs autres outils. Je peux développer aussi bien sous docker qu'avec ssh, etc. Le programmeur qui peut travailler avec un simple éditeur de texte peut travailler quasiment partout, et dans tous les langages. Cela ne signifie pas qu'il faille pour autant éviter d'utiliser des outils: au contraire, les bons outils sont essentiels. Lecture optionnelle: What is “modern” programming? (billet en anglais du professeur)\n"},{"id":7,"href":"/inf1901-teluq/docs/modules/module3/activite-3-2/","title":"Activité 3.2","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":8,"href":"/inf1901-teluq/docs/modules/module4/activite-4-2/","title":"Activité 4.2","section":"Module 4: Les entrées et sorties","content":" "},{"id":9,"href":"/inf1901-teluq/docs/modules/module5/activite-5-2/","title":"Activité 5.2","section":"Module 5. La programmation orientée-objet: héritage et le polymorphisme","content":" "},{"id":10,"href":"/inf1901-teluq/docs/modules/module2/","title":"Module 2: Introduction à l'apprentissage machine","section":"Modules","content":" Module 2 # Dans le module 2, le concept de programme est exploré en profondeur, constituant une étape clé pour maîtriser les bases de la programmation. Ce module introduit les éléments fondamentaux qui composent un programme : les types, les fonctions, les méthodes et les variables. Les types permettent de définir la nature des données manipulées, tandis que les fonctions et les méthodes offrent des outils pour structurer le code de manière modulaire et réutilisable. Les variables, quant à elles, servent à stocker et gérer des informations de façon efficace. À travers des exemples concrets et des exercices pratiques, ce module montre comment ces composants s’assemblent pour créer des programmes cohérents et fonctionnels, jetant ainsi les bases d’un apprentissage solide.\nLe module 2 aborde également la distinction entre les variables de classe et les variables locales, une notion essentielle pour organiser le code de manière claire et efficace. Les variables de classe, accessibles à l’échelle d’un programme ou d’un objet, facilitent la gestion des données globales, tandis que les variables locales, restreintes à un contexte spécifique, favorisent la clarté et la modularité du code. Grâce à des activités pratiques, notamment en Java, ce module permet de comprendre la portée et le cycle de vie des variables. En s’appuyant sur les exemples du manuel Java pas à pas et du site web du cours, il offre une opportunité de consolider les compétences en programmation tout en développant la capacité à concevoir des solutions logiques et bien structurées.\nLe cours comprend aussi plusieurs exemples de code Java exécutable en ligne, comme cet exemple :\nHelloWorld.javapublic class HelloWorld { public static void main(String[] args) { if(args.length \u0026gt; 0 \u0026amp;\u0026amp; args[0].equals(\u0026#34;fr\u0026#34;)) { System.out.println(\u0026#34;Bonjour, INF 1220 !\u0026#34;); } else { System.out.println(\u0026#34;Hello, INF 1220 !\u0026#34;); } System.out.println(\u0026#34;Bonjour, INF 1220 !\u0026#34;); } } Exécuter Ce programme Java, appelé HelloWorld, est un petit exemple qui affiche le message \u0026ldquo;Bonjour, INF 1220 !\u0026rdquo; à l\u0026rsquo;écran. Imaginez une classe comme une boîte qui contient des instructions, et ici, notre boîte s\u0026rsquo;appelle HelloWorld. À l\u0026rsquo;intérieur, il y a une action spéciale nommée main, qui est comme la porte d\u0026rsquo;entrée du programme : c\u0026rsquo;est par là que tout commence quand vous lancez le code. La ligne public static void main(String[] args) crée cette porte d\u0026rsquo;entrée, et String[] args est juste un moyen de donner des informations supplémentaires au programme (on ne s\u0026rsquo;en sert pas ici). Ensuite, l\u0026rsquo;instruction System.out.println(\u0026ldquo;Bonjour, INF 1220 !\u0026rdquo;); est comme une commande qui dit à l\u0026rsquo;ordinateur d\u0026rsquo;écrire \u0026ldquo;Bonjour, INF 1220 !\u0026rdquo; dans la console, un peu comme si vous écriviez sur une feuille. En gros, ce code est une première étape pour apprendre à donner des ordres simples à l\u0026rsquo;ordinateur avec Java !\nVous devriez pouvoir exécuter le code et prendre connnaissance du résultat. Vous pouvez aussi modifier le code, etc. À la fin du cours, vous serez capable de réaliser des tâches complexes avec la programmation Java.\n"},{"id":11,"href":"/inf1901-teluq/docs/modules/module2/oriente/","title":"Qu’est-ce qu’un langage de programmation orientée-objet?","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":12,"href":"/inf1901-teluq/docs/modules/module1/robot/","title":"Robot conversationnel et intelligence artificielle","section":"Module 1: Algorithme et pseudocode","content":"Dans ce cours, vous êtes encouragé à utiliser l\u0026rsquo;intelligence artificielle pour mieux apprendre à programmer. L\u0026rsquo;Université TÉLUQ met à votre disposition un robot conversationnel dédié au cours. Ce robot, basé sur des technologies avancées d\u0026rsquo;IA, vous permettra d\u0026rsquo;obtenir des réponses personnalisées à vos questions, de clarifier des concepts complexes et de recevoir des exemples de code pertinents. En interagissant avec cet outil, vous pourrez approfondir votre compréhension des notions abordées, pratiquer vos compétences en programmation et progresser à votre rythme, tout en bénéficiant d\u0026rsquo;un soutien adapté à vos besoins. Vous pouvez aussi utiliser d\u0026rsquo;autres outils comme ChatGTP, copilot, Grok, etc.\n"},{"id":13,"href":"/inf1901-teluq/docs/erreurs/","title":"Vous avez trouvé une erreur?","section":"Docs","content":"Amélioration continue du cours Le site web de ce cours est continuellement mis à jour avec de nouveaux exemples, de nouvelles explications, de nouvelles références. Le manuel est aussi mis à jour quand nous trouvons des erreurs.\nVous pouvez, de manière anonyme, nous faire parvenir vos corrections lorsque vous trouvez des erreurs sur le site. Nous apprécions toujours vos commentaires constructifs.\nNote: plusieurs étudiants partagent avec nous des suggestions de sites ou de vidéos en anglais. Bien que le cours fait quelques liens vers des sites en anglais, nous évitons l'anglais autant que possible. Si vous avez des suggestions, essayez de rester en français.\nIl arrive qu'on se trompe! Quand ça se produit, prenez la peine de nous en informer. Nous corrigeons toujours rapidement nos erreurs.\n"},{"id":14,"href":"/inf1901-teluq/docs/modules/module3/activite-3-3/","title":"Activité 3.3","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":15,"href":"/inf1901-teluq/docs/modules/module4/exercices-4-1/","title":"Exercices 4.1","section":"Module 4: Les entrées et sorties","content":" "},{"id":16,"href":"/inf1901-teluq/docs/modules/module5/exercices-5-1/","title":"Exercices 5.1","section":"Module 5. La programmation orientée-objet: héritage et le polymorphisme","content":" "},{"id":17,"href":"/inf1901-teluq/docs/modules/module2/typeoperateur/","title":"Introduction aux types de base et à leurs opérateurs.","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":18,"href":"/inf1901-teluq/docs/modules/module3/","title":"Module 3: Les structures de données, de contrôle et d'itération en Java","section":"Modules","content":" Module 3 # Le module 3 se concentre sur les structures essentielles de la programmation en Java, en abordant les structures de données, de contrôle et d’itération. Les structures de données, telles que les tableaux et les listes, permettent d’organiser et de manipuler des ensembles d’informations de manière efficace. Les structures de contrôle, comme les conditions et les branchements, offrent les outils nécessaires pour prendre des décisions logiques dans un programme. Quant aux structures d’itération, elles permettent d’exécuter des blocs de code de manière répétée, facilitant le traitement de données complexes. À travers des exemples pratiques et des exercices tirés du manuel Java pas à pas et du site du cours, ce module enseigne comment combiner ces structures pour créer des programmes robustes et bien organisés.\nCe module explore également la manipulation des chaînes de caractères, une compétence clé pour traiter des données textuelles en Java. Les apprenants découvrent comment utiliser les méthodes associées aux chaînes pour effectuer des opérations comme la concaténation, la recherche ou le remplacement de texte. Par ailleurs, le module met l’accent sur la mise en œuvre d’algorithmes à l’aide de boucles, permettant de résoudre des problèmes de manière systématique et efficace. En s’appuyant sur des activités pratiques, ce module aide à développer une compréhension approfondie des techniques algorithmiques et renforce la capacité à concevoir des solutions programmées adaptées à des besoins variés, tout en consolidant les compétences acquises dans les modules précédents.\n"},{"id":19,"href":"/inf1901-teluq/docs/modules/module2/exercices-2-1/","title":"Exercices 2.1","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":20,"href":"/inf1901-teluq/docs/modules/module3/exercices-3-1/","title":"Exercices 3.1","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":21,"href":"/inf1901-teluq/docs/feuille-de-route/","title":"Feuille de route","section":"Docs","content":" Feuille de route Prévoyez environ 9 heures de travail pendant quinze semaines. Il n'est pas possible, pour la plupart des étudiants, de réussir ce cours en ne prenant qu'une poignée d'heures par semaine. Chaque étudiant a sa propre date de départ et date de fin de cours personnalisée. La date à laquelle l'étudiant doit passer son examen est déterminé par l'Université: celle-ci vous fera parvenir les détails en temps opportun. Le professeur ne peut pas changer vos dates de départ, de fin ou d'examen: vous devez joindre l'Université si vous souhaitez les modifier. Il n'y a pas de dates fixes pour la remise des travaux, mais il est recommandé de prévoir une semaine de travail pour la réalisation de chacun de ceux-ci et de les remettre selon l'ordre de présentation du cours. Tous les étudiants ne vont pas avancer au même rythme dans le cours. Nous vous suggérons cependant de remettre vos travaux notés lors de la semaine indiquée par le tableau suivant :\nActivitésemaine de remise\tTravail noté 12\tTravail noté 25\tTravail noté 38\tTravail noté 410\tTravail noté 514\tExamen sous surveillance15 ou plus Il est parfaitement normal de consacrer des dizaines d'heures à compléter un travail noté et les activités préparatoires. Il est de votre responsabilité de trouver le temps nécessaire.\nSi vous trouvez certaines sections du cours plus faciles, n'hésitez pas à avancer plus rapidement. Organisation du cours Module 1. Algorithme et pseudocode. Dans ce module, vous verrez comment concevoir des algorithmes simples et comment les présenter de manière précise en français. Module 2. Introduction au langage Java. Le concept de programme. Les types, les fonctions, les méthodes, les variables. Les variables de classe et les variables locales. Module 3. Les structures de données, de contrôle et d'itération en Java. Manipulation de chaînes de caractères. Mise en oeuvre d'algorithmes avec des boucles. Module 4. Les entrées et sorties. Module 5. La programmation orientée-objet: héritage et le polymorphisme. "},{"id":22,"href":"/inf1901-teluq/docs/modules/module1/ordinateurs/","title":"Les ordinateurs","section":"Module 1: Algorithme et pseudocode","content":" Court historique des langages de programmation # L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière.\nL’avènement des ordinateurs modernes dans les années 1940-1950 marque un tournant décisif. Les premiers langages de programmation apparaissent pour répondre aux besoins de calcul scientifique, commercial et logique. Parmi eux, FORTRAN (1954) facilite les calculs scientifiques, LISP (1958) introduit des concepts d’intelligence artificielle et de traitement symbolique, et COBOL (1959) s’impose dans la gestion des données commerciales. Ces langages, bien que rudimentaires comparés aux standards actuels, posent les bases des paradigmes de programmation modernes.\nAu fil des décennies, les langages évoluent pour offrir plus d’abstraction, de flexibilité et d’accessibilité. Dans les années 1980 et 1990, des langages comme C++ (1983), Python (1991), Java (1995), JavaScript (1995) et PHP (1995) voient le jour, chacun répondant à des besoins spécifiques : performance pour C++, simplicité pour Python, portabilité pour Java, interactivité web pour JavaScript, ou développement web dynamique pour PHP. Aujourd’hui, ces langages dominent l’industrie, comme le montre le classement 2017 de l’IEEE Spectrum, qui reflète leur popularité et leur polyvalence.\nTous ces langages partagent un objectif commun : permettre aux programmeurs de décrire des solutions à des problèmes en s’éloignant progressivement des contraintes du matériel. Pour comprendre leur rôle, il est essentiel de se pencher sur le fonctionnement des ordinateurs.\nRésumé de l’architecture des ordinateurs et de l’abstraction des langages # Les ordinateurs modernes s’appuient sur deux concepts fondamentaux : la machine de Turing, théorisée par Alan Turing, qui définit une machine capable d’exécuter n’importe quel algorithme, et l’architecture de von Neumann, qui structure les ordinateurs autour de quatre composantes principales. Premièrement, la mémoire stocke à la fois les données et les programmes, une innovation clé par rapport aux machines antérieures où les instructions étaient fixes. Deuxièmement, l’unité de contrôle orchestre l’exécution des instructions en suivant un séquençage précis. Troisièmement, l’unité arithmétique et logique effectue les calculs de base, comme les additions ou les comparaisons. Enfin, les interfaces d’entrée/sortie permettent d’interagir avec l’utilisateur ou d’autres systèmes, via des périphériques comme les claviers, écrans ou réseaux.\nDans un langage plus accessible, un ordinateur contemporain se compose de processeurs (CPU), de mémoire vive (RAM) pour les calculs temporaires, de stockage à long terme (disques durs ou SSD), de processeurs graphiques (GPU) pour le rendu visuel, et de cartes d’entrée/sortie pour la connectivité. La carte mère agit comme un chef d’orchestre, coordonnant les échanges entre ces éléments. Par exemple, lorsqu’un programme s’exécute, le CPU lit les instructions depuis la RAM, effectue les calculs nécessaires, et envoie les résultats vers la mémoire ou un périphérique de sortie, comme un écran.\nLes processeurs se déclinent en plusieurs architectures. Dans les ordinateurs personnels, les puces x64 (ou x86-64), produites par Intel et AMD, dominent grâce à leur puissance et leur compatibilité. Dans les appareils mobiles, comme les smartphones, les processeurs ARM, plus économes en énergie, sont privilégiés. La mémoire vive repose sur la technologie DRAM, rapide mais volatile, tandis que le stockage à long terme utilise majoritairement la mémoire flash, comme dans les SSD, pour sa rapidité et sa fiabilité.\nLes langages de programmation jouent un rôle crucial en traduisant des instructions humaines en commandes compréhensibles par ces composants matériels. Leur niveau d’abstraction varie : les langages de bas niveau, comme l’assembleur, sont proches du matériel et offrent un contrôle précis mais exigent une expertise technique. À l’opposé, les langages de haut niveau, comme Python ou Java, simplifient le développement en masquant les détails matériels, ce qui les rend plus accessibles et adaptés à des applications complexes, comme le développement web ou l’intelligence artificielle.\nDans ce cours, nous explorerons le langage Java, largement adopté dans l’industrie pour sa portabilité, sa robustesse et sa polyvalence. Utilisé dans des domaines variés, des applications mobiles Android aux systèmes d’entreprise, Java illustre parfaitement comment un langage de haut niveau peut répondre à des besoins modernes tout en s’appuyant sur les principes fondamentaux de l’informatique.\nJava pas à pas Nous vous invitons maintenant à lire le chapitre 1 du manuel Java Pas à Pas. Vous devez charger le document PDF. "},{"id":23,"href":"/inf1901-teluq/docs/modules/module4/","title":"Module 4: Les entrées et sorties","section":"Modules","content":" Module 4 # Le module 4 se consacre aux concepts d’entrées et de sorties, des composantes fondamentales pour interagir avec les utilisateurs et gérer les données dans un programme Java. Les entrées permettent de collecter des informations provenant de sources externes, telles que les saisies clavier ou les fichiers, tandis que les sorties servent à afficher ou à enregistrer les résultats, que ce soit à l’écran ou dans des fichiers. Ce module explore les techniques et les classes Java dédiées à ces opérations, comme Scanner pour les entrées et System.out pour les sorties. À travers des exercices pratiques tirés du manuel Java pas à pas et du site du cours, les apprenants acquièrent la capacité de concevoir des programmes interactifs et dynamiques.\nCe module met également l’accent sur la gestion efficace des flux d’entrées et de sorties, en introduisant des notions telles que la lecture et l’écriture de fichiers. Les apprenants découvrent comment manipuler des données textuelles ou numériques pour répondre à des besoins spécifiques, tout en apprenant à gérer les erreurs potentielles liées à ces opérations. En s’appuyant sur des exemples concrets, ce module renforce la compréhension des mécanismes d’interaction entre un programme et son environnement, permettant ainsi de développer des applications plus robustes et polyvalentes. Ces compétences s’intègrent aux connaissances acquises dans les modules précédents, consolidant une approche pratique et structurée de la programmation.\n"},{"id":24,"href":"/inf1901-teluq/docs/modules/module4/travail-note-4/","title":"Travail noté 4","section":"Module 4: Les entrées et sorties","content":" "},{"id":25,"href":"/inf1901-teluq/docs/modules/module5/travail-note-5/","title":"Travail noté 5","section":"Module 5. La programmation orientée-objet: héritage et le polymorphisme","content":" "},{"id":26,"href":"/inf1901-teluq/docs/modules/module2/activite-2-4/","title":"Activité 2.4","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":27,"href":"/inf1901-teluq/docs/modules/module1/algorithmes/","title":"Les algorithmes","section":"Module 1: Algorithme et pseudocode","content":" Les algorithmes The etymology of program is pro ‘before’ + graphein ‘write’. I think of programming as making a plan that will be executed in the future, something that every human does from time to time. The hard part is that a computer has to execute the plan, and computers are incredibly stupid. Dealing with such stupidity requires more patience and determination than many people have. (Peter Turney) Préalables Nous supposons dans ce cours que vous avez complété les mathématiques du collégial et que vous avez de bonnes aptitudes en ce qui a trait aux raisonnements formels. Dans ce premier module, vous aurez à exprimer la solution de certains problèmes en terme de variables, de boucles et d'embranchement. Il ne s'agit pas de notions avancées : vous devriez être familier avec ces notions. Les boucles font partie implicitement du calcul d'une somme ou d'un produit scalaire. Les variables en informatique sont une notion voisine des variables en algèbre. Les embranchements sont des notions de base en logique élémentaire. Nous supposons une maîtrise de ces notions. Vous êtes responsables de vous assurez que vous avez la préparation nécessaire pour suivre le cours INF 1220.\nIntroduction Le processus systématique de résolution d'un problème donné s'appelle algorithme. La notion d'algorithme formel est vue dans le cadre des cours de mathématiques du secondaire, notamment dans le contexte de la théorie des graphes et des algorithmes d'optimisation. Comme point de départ dans le cours INF 1220, nous revisitons et approfondissons brièvement cette notion fondamentale.\nUn algorithme est donc une suite d'actions pour répondre à un problème de traitement de l'information. Ces actions peuvent être mathématiques (ex. somme = a + b), de contrôles (ex. SI a \u003e b ALORS) ou d'itérations (ex. TANT QUE a \u003e b FAIRE). Pour décrire ces algorithmes, il existe également plusieurs formalismes, certains utiliseront des formalismes mathématiques alors que d'autres utiliseront des pseudo-codes. Encore là dans plusieurs formats pour représenter un pseudo-code, il n'existe pas de normes uniques! En cuisine, une recette est un exemple d'algorithme si celle-ci comporte une séquence d'instructions précises. Pouvoir rédiger de manière précise une recette afin que d'autres cuisiniers puissent reproduire la même séquence d'opération est de facto de la programmation informatique. Si vous avez fait l'expérience du manuel de recette de quelqu'un d'autre (par ex., votre grand-mère), vous avez peut-être découvert qu'il peut être difficile de suivre des consignes de quelqu'un d'autre surtout quand celles-ci ne sont pas suffisamment précises. Une recette de cuisine est du pseudo-code.\nAvant l'invention du GPS, il était commun d'expliquer à des amis ou des parents comment se rendre à un lieu donné en suivant une série d'instructions. Il arrivait souvent, malheureusement, que ces instructions n'étaient pas assez précises et que les gens se perdent. Expliquer à quelqu'un comment se rendre à un lieu donné est un exemple de programmation informatique. Votre explication est du pseudo-code.\nIl est essentiel de comprendre ce qu'est le pseudo-code: il s'agit d'une façon de décrire un algorithme afin que d'autres êtres humains puissent vous comprendre. Il faut donc interpréter le pseudo-code en utilisant son jugement humain de la même façon que vous interprétez tout autre texte ou discours. Pouvoir lire un algorithme, décrit en pseudo-code, est une compétence essentielle en informatique. Il faut être capable de comprendre d'autres informaticiens sans nécessairement exiger que ceux-ci utilisent du code informatique dans un langage particulier (par ex., Java). Programmer et faire de l'informatique exige de pouvoir bien communiquer avec les autres informaticiens indépendamment de langages de programmation spécifiques.\nPour un programmeur d'expérience, s'exprimer à l'aide d'un pseudo-code est chose aisée. Pour le commun des mortels, c'est un peu plus difficile. La blague suivante illustre le problème.\nUne femme demande à son programmeur de mari : « Va au supermarché acheter une bouteille de lait. Et si ils ont des œufs, prends en 6 ». Le mari revient avec six bouteilles de lait. Sa femme lui demande pourquoi il a pris six bouteilles. « Parce qu'ils avaient des oeufs » répond-il. Quand on rédige un pseudo-code, il faut tout spécifier, comme si on s'adressait à quelqu'un qui prend tout littéralement, sans aucun jugement. Pour devenir un programmeur, pour penser comme un programmeur, il faut s'habituer à rédiger des séquences d'instructions précises. La lecture et la rédaction de pseudo-codes relativement simples peut être une bonne pratique.\nLe pseudocode est destiné à être lu par l'humain, et il peut être écrit de diverses manières tant que l'humain le comprend. Le cours ne vise pas à vous permettre de comprendre une syntaxe particulière de pseudocode, mais bien le pseudocode en général.\nEn résumé: Qu'est-ce qu'un algorithme ? Un algorithme est une suite finie et ordonnée d'instructions permettant de résoudre un problème ou d'accomplir une tâche spécifique. Il s'agit d'une méthode systématique, exprimée de manière précise, qui garantit un résultat correct lorsqu'elle est exécutée. Les algorithmes sont au cœur de l'informatique, car ils décrivent comment un programme doit fonctionner pour atteindre un objectif.\nExemples d'algorithmes dans la vie quotidienne :\nUne recette de cuisine (série d'étapes pour préparer un plat). Les instructions pour assembler un meuble. En informatique, un algorithme peut, par exemple, trier une liste de nombres ou calculer le chemin le plus court entre deux points.\nEn résumé: Qu'est-ce que le pseudo-code ? Le pseudo-code est une manière d'écrire un algorithme en utilisant un langage simplifié, proche du langage naturel, mais structuré comme un programme informatique. Il n'est pas destiné à être exécuté directement par un ordinateur, mais sert à décrire la logique d'un algorithme de manière claire et compréhensible, indépendamment d'un langage de programmation spécifique.\nLe pseudo-code utilise des conventions comme :\nSI, ALORS, SINON pour les conditions. POUR, TANT QUE pour les boucles. Des instructions comme écrire ou lire pour les entrées/sorties. Exemple de pseudo-code pour calculer la somme de deux nombres :\nlire nombre1 lire nombre2 somme ← nombre1 + nombre2 écrire somme Le pseudo-code permet aux programmeurs de planifier la logique avant de la traduire dans un langage comme Python, C++ ou Java.\nEn résumé, un algorithme est une méthode pour résoudre un problème, tandis que le pseudo-code est un outil pour exprimer cet algorithme de manière claire et universelle. Ces deux concepts sont essentiels pour concevoir des solutions informatiques efficaces.\nTerminologie de base Un algorithme prend habituellement des données et produit un résultat. Par exemple, un algorithme cherchant à déterminer si un nombre est pair, pourra recevoir un nombre en paramètre et il pourra produire comme réponse une valeur Booléenne (vrai ou faux). Un même algorithme va donc généralement pouvoir être exécuté sur différentes données et pouvoir fournir des réponses différentes. En ce sens, une fonction (au sens mathématique) comme f(x) = a x + b peut être décrite comme étant un algorithme. Une fonction doit toujours produire la même valeur étant donnée les mêmes données. Un algorithme n'est pas limité de cette manière. Par exemple, un algorithme pourrait servir à choisir un nom aléatoirement au sein d'une liste. D'une exécution à l'autre, l'algorithme pourrait produire des valeurs différentes avec les mêmes données. La plupart des algorithmes en pratique sont itératifs. Une itération est la répétition d'un processus. Si vous devez teindre une clôture, vous allez peut-être teindre chaque planche une à une. Nous dirons alors que vous itérez sur les planches. Mais comment saurez-vous où vous êtes rendu si vous prenez une pause? Peut-être pourrez-vous poser un petit drapeau sur la planche que vous êtes en train de teindre. On dira alors que le drapeau est un itérateur, c'est-à-dire un indicateur de votre progrès dans votre itération. À chaque étape où vous déplacez le drapeau d'une planche à l'autre, nous pourrons dire que vous incrémentez la position du drapeau. Si jamais vous deviez faire un retour à la planche précédente, nous dirons que vous décrémentez le drapeau.\nEn informatique, nous n'utilisons pas de drapeaux physiques. Pour savoir où on est rendu, on utilise des compteurs, le plus souvent des valeurs entières. Quand on dit qu'on incrémente un entier, on veut généralement dire qu'on ajoute \"1\" à sa valeur.\nNous obtenons alors la notion de boucle: nous effectuons une tâche donnée tant qu'une condition n'est pas satisfaite. Cette vidéo présente le concept de boucle:\nEn informatique on fait souvent référence à la notion d'impression à l'écran. Le plus souvent cela fait référence à l'affichage à l'écran d'un message ou d'un texte.\nCalcul de la moyenne Pour illustrer la notion de pseudo-code, commençons par un exemple relativement simple.\nSupposons que nous avons un tableau de notes (par ex., les notes 10.4, 12.6, 18.7, 5.0) et que nous désirons calculer la moyenne. On utilise le convention que si le tableau se nomme 'notes', alors la première note (par ex., 10.4) est notes[0], la seconde note est notes[1]... et ainsi de suite jusqu'à notes[3]. Évidemment, dans ce cas, on sait qu'il y'a 4 notes, mais il plus pratique d'écrire le pseudo-code de manière générale. On fera donc référence à la longueur du tableau (au nombre d'éléments qu'il contient) comme étant un paramètre. Pour visiter tous les éléments, on peut initialiser une valeur entière à 0, et l'incrémenter de 1 tant qu'elle demeure plus petite que la longueur du tableau.\nCalcul de la moyenne Entrez un tableau de nombres rationnels séparés par des virgules et exécutez le pseudocode pour calculer la moyenne.\nPseudocode\nTableau de quatre nombres rationnels : notes Variables : Nombre entier : iterateur = 0 Nombre rationnel : moyenne = 0 Sorties : Nombre rationnel : moyenne TANT QUE iterateur \u003c la longueur de notes FAIRE moyenne = moyenne + notes[iterateur] iterateur = iterateur + 1 FIN TANT QUE moyenne = moyenne / la longueur de notes État\nTableau : []\nItérateur : 0\nMoyenne : 0\nProchaine étape Réinitialiser Observez comment on termine la boucle \"TANT QUE\" avec une ligne \"FIN TANT QUE\". Ce n'est pas nécessaire, mais vous devez être clair et précis quant au début et à la fin de vos opérations. On peut aussi indiquer le début et la fin d'une boucle avec l'indentation, ou tout autre moyen compris par les êtres humains.\nL'expression \"TANT QUE\" est associée à une condition qui peut être vraie ou fausse. L'exécution se poursuit tant que l'expression est vraie, et elle se termine lorsque l'expression est fausse.\nCompter le nombre de voyelles d'un mot entrées au clavier Exécutez ce pseudocode :\nCompteur de voyelles Entrez une chaîne de caractères et exécutez le pseudocode pour compter les voyelles.\nPseudocode\nEntrées : Chaîne de caractères : chaine = \"\" Sorties : Entier : nbVoyelle = 0 Imprimer à l'écran \"Veuillez entrer un mot au clavier suivi de la touche entrée\" Saisir le mot au clavier et assigner à la variable chaine POUR TOUT caractère c dans chaine FAIRE SI c == 'a' OU c == 'e' OU c == 'i' OU c == 'o' OU c == 'u' OU c == 'y' ALORS nbVoyelle = nbVoyelle + 1 FIN SI FIN POUR État\nChaîne : \"\"\nCaractère courant : -\nNombre de voyelles : 0\nProchaine étape Réinitialiser Note: observez comment on termine la condition \"SI\" avec une ligne \"FIN SI\".\nNote: observez comment l'algorithme comprend comme consigne l'impression à l'écran d'un résultat. Il s'agit implicitement d'un résultat ou d'une conséquence de l'algorithme.\nConcevoir un algorithme Afin de concevoir un algorithme, il s'agit de bien analyser le problème en identifiant les entrées, les sorties et le traitement des données pour en arriver aux résultats escomptés. Il faut voir l'algorithme comme une solution pas à pas que n'importe quel programmeur pourrait reprendre et implémenter dans un langage spécifique tel que le Java, le C++ ou le Python. En général, pour concevoir un algorithme, il faut suivre les étapes suivantes : Étape 1 Lire et bien comprendre l’énoncé du problème à résoudre. Étape 2 Définir les résultats du problème, c'est-à-dire les sorties. Définir les données du problème, c'est-à-dire les entrées. Définir le traitement, c'est-à-dire les relations permettant d’obtenir les résultats à partir des données. Étape 3 Écrire l’algorithme en respectant la structure pseudo-code. Syntaxe d'un algorithme Voici un aperçu des différents éléments pouvant être utilisés pour proposer une résolution à un problème sous la forme d'algorithme. Comme nous l'avions spécifié précédemment, il n'y a pas de normes strictes dans l'écriture d'un pseudo-code (en comparaison à un langage de programmation qui est stricte). L'essentiel est d'utiliser les structures présentées ci-bas, d'être concis et exact dans les instructions. S'il y a un doute sur la concision ou bien la compréhension d'une étape de l'algorithme, c'est peut-être que cette étape doit être subdivisée en plusieurs sous-étapes. Les Entrées, Variables et Sorties Un algorithme commence par la déclaration des données en entrées, c'est à dire les données qui sont soit fournies d'emblée à l'algorithme (ex. un texte à déchiffrer, des données financières à analyser) ou bien fournies par un utilisateur (ex. via le clavier, souris, etc.).\nPar la suite, il est nécessaire de déclarer les variables de travail de l'algorithme. Une variable a un nom et une valeur. Par exemple, la variable x peut avoir la valeur 1. La valeur d'une variable peut changer dans le temps. Ces variables sont utilisées essentiellement pour conserver des informations nécessaires au traitement effectué par l'algorithme. Les variables peuvent avoir plusieurs types... par exemple, une variable peut contenir des chaînes de caractères, d'autres variables peuvent ne contenir que des entiers, etc. Enfin, les sorties sont les données qui sont les résultats du traitement effectué par l'algorithme. Ces sorties sont retournées soit à l'utilisateur, soit à d'autres algorithmes. En effet, il est possible de diviser la résolution de problèmes complexes en plusieurs algorithmes qui peuvent \"s'appeler\" entre eux. Nous ferons plus tard le parallèle entre un algorithme et une fonction dans un langage de programmation.\nLes opérations On décrit généralement un algorithme comme une liste d'opérations. Par exemple, on peut prendre deux nombres et les additionner. On peut ajouter 1 à la valeur d'une variable. Les opérations permises dépendent de notre modèle de calcul. On fait cependant souvent certaines hypothèses: on suppose que la plupart des opérations mathématique de bases sont supportées (addition, comparaison, multiplication, soustraction, etc.). Il y a plusieurs manières d'exprimer les opérations. Par exemple, la multiplication de deux variables peut s'exprimer avec les expressions x * y , x y , x \u0026times; y , x \u0026times; y, etc. Il y a plusieurs manières de noter ces opérations. Par exemple, l'expression x \u0026larr; 1 peut être utilisée pour assigner la valeur 1 à la variable x. On peut aussi tout simplement écrire x = 1. Dans un autre contexte, l'expression x = 1 pourrait aussi désigner la comparaison (« est-ce que x vaut 1 ? »). En s'inspirant de certains langages de programmation, on peut aussi utiliser une expression telle que x == 1 pour indiquer que nous faisons une comparaison avec la valeur 1 (et non une assignation). L'important est que l'intention soit claire et précise pour l'être humain qui vous lit.\nLes structures de contrôle alternatives (l'embranchement) On peut concevoir un algorithme qui ne comprend qu'une liste d'opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d'éléments, et on risque de devoir répéter beaucoup d'opérations.\nLes structures de contrôle permettent à l'algorithme de faire des choix de traitement en fonction de conditions. On peut également parler de branchement, terme provenant des premiers ordinateurs où les sorties de cartes de contrôle correspondaient littéralement à des câbles menant à d'autres composantes de l'ordinateur. Une structure de contrôle correspond à l'action de tester des variables de contrôle et selon les résultats d'effectuer des opérations ou non. En pratique, ces structures correspondent à poser des questions avec la syntaxe suivante : SI conditions ALORS opérations FIN SI. Il peut y avoir plusieurs conditions dans une structure de contrôle et la logique booléenne est utilisée pour les construire. Par exemple, SI a est égal 0 ET b est égal 1 ALORS faire c FIN SI. Dans la notion de pseudo-code, il est également possible de faire une suite de structures de contrôle avec la syntaxe suivante : SI conditionA ALORS opérations SINON SI conditionB ALORS opérations SINON SI conditionC ALORS [et ainsi de suite] FIN SI. Voici un exemple d'utilisation des structures de contrôle plus riche :\nCatégorie d'âge Entrez un âge et exécutez le pseudocode pour déterminer la catégorie d'âge.\nPseudocode\nSI age \u003c= 10 ALORS Imprimer à l'écran \"Vous êtes un enfant\" SINON SI age \u003e 10 ET age \u003c 18 ALORS Imprimer à l'écran \"Vous êtes un adolescent\" SINON SI age \u003e= 18 ET age \u003c 65 ALORS Imprimer à l'écran \"Vous êtes un adulte\" SINON Imprimer à l'écran \"Vous êtes une personne âgée\" FIN SI État\nÂge : 0\nSortie : -\nProchaine étape Réinitialiser Les structures de contrôle itératives (la boucle) Il arrive régulièrement dans la résolution d'un problème qu'il est nécessaire de réaliser à plusieurs reprises une ou des opérations sur un ensemble de données. Par exemple, supposons qu'il est nécessaire de trouver le plus petit nombre dans un tableau d'entiers. Il sera forcément nécessaire d'itérer dans le tableau, une ligne à la fois, et de comparer les nombres entre eux. Pour ce faire, nous utiliserons deux éléments de syntaxe, soit le TANT QUE _ FAIRE ou bien le POUR TOUT _ FAIRE. Voici deux exemples de l'utilisation de ces deux approches : Exécution des Pseudocodes de Recherche du Minimum Cette page décrit l'exécution détaillée de deux pseudocodes qui trouvent le minimum dans un tableau d'entiers. Pour l'exemple, nous utilisons le tableau tableau = [7, 3, 9, 1, 5]. Pseudocode 1 : Boucle POUR TOUT Entrées : Tableau d'entiers : tableau[100] Sorties : Entier minimum\nminimum = tableau[0] POUR TOUT Entier e de tableau FAIRE SI e \u0026lt; minimum ALORS minimum = e; FIN SI FIN POUR TOUT Exécution détaillée (tableau = [7, 3, 9, 1, 5]) Initialisation La variable est initialisée comme suit :\ntableau = [7, 3, 9, 1, 5] (longueur = 5) minimum = tableau[0] = 7 Boucle POUR TOUT La boucle itère sur chaque élément e du tableau :\nItération 1 (e = 7)\nComparer 7 \u003c 7 ? Non, minimum reste 7. Itération 2 (e = 3)\nComparer 3 \u003c 7 ? Oui, mettre à jour minimum = 3. Itération 3 (e = 9)\nComparer 9 \u003c 3 ? Non, minimum reste 3. Itération 4 (e = 1)\nComparer 1 \u003c 3 ? Oui, mettre à jour minimum = 1. Itération 5 (e = 5)\nComparer 5 \u003c 1 ? Non, minimum reste 1. Résultat Le minimum du tableau est : 1\nRésumé des étapes Itération e minimum Initialisation - 7 1 7 7 2 3 3 3 9 3 4 1 1 5 5 1 Pseudocode 2 : Boucle TANT QUE Entrées : Tableau d'entiers : tableau[100] Sorties : Entier minimum\nminimum = tableau[0] Entier iterateur = 0; TANT QUE iterateur \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS minimum = tableau[iterateur]; FIN SI iterateur = iterateur + 1; FIN TANT QUE Exécution détaillée (tableau = [7, 3, 9, 1, 5]) Initialisation Les variables sont initialisées comme suit :\ntableau = [7, 3, 9, 1, 5] (longueur = 5) minimum = tableau[0] = 7 iterateur = 0 Boucle TANT QUE La boucle s'exécute tant que iterateur \u003c 5 :\nItération 1 (iterateur = 0)\nAccéder à tableau[0] = 7 Comparer 7 \u003c 7 ? Non, minimum reste 7. Incrémenter iterateur = 0 + 1 = 1 Itération 2 (iterateur = 1)\nAccéder à tableau[1] = 3 Comparer 3 \u003c 7 ? Oui, mettre à jour minimum = 3. Incrémenter iterateur = 1 + 1 = 2 Itération 3 (iterateur = 2)\nAccéder à tableau[2] = 9 Comparer 9 \u003c 3 ? Non, minimum reste 3. Incrémenter iterateur = 2 + 1 = 3 Itération 4 (iterateur = 3)\nAccéder à tableau[3] = 1 Comparer 1 \u003c 3 ? Oui, mettre à jour minimum = 1. Incrémenter iterateur = 3 + 1 = 4 Itération 5 (iterateur = 4)\nAccéder à tableau[4] = 5 Comparer 5 \u003c 1 ? Non, minimum reste 1. Incrémenter iterateur = 4 + 1 = 5 Fin de la boucle : iterateur = 5, qui n’est pas inférieur à 5, donc sortie.\nRésultat Le minimum du tableau est : 1\nRésumé des étapes Itération iterateur tableau[iterateur] minimum Initialisation 0 - 7 1 0 7 7 2 1 3 3 3 2 9 3 4 3 1 1 5 4 5 1 Une structure de contrôle itérative n'est pas distincte des structures de contrôle avec des SI ALORS. En effet les boucles et autres structures de contrôle itératives sont mise en oeuvre avec des SI ALORS et une ou plusieurs variables qui sont modifiées au sein de la boucle.\nComposition Dans la pratique, un algorithme peut comporter plusieurs structures de contrôle itératives, plusieurs structures de contrôle alternatives et plusieurs opérations. On peut les combiner de diverses manières. Il est possible, par exemple, d'avoir une boucle TANT QUE au sein d'une autre boucle TANT QUE.\nTANT QUE x \u003e 0 FAIRE TANT QUE x \u003e 10 FAIRE x = x - 1 FIN TANT QUE FIN TANT QUE La fin d'un algorithme Un algorithme continue à s'exécuter tant qu'il reste des operations à faire. L'algorithme prend fin lorsque nous rencontrons la fin du pseudo-code ou lorsque le programmeur invoque la fin spécifiquement. Dans l'exemple suivant, le programmeur demander à ce que l'on cesse l'exécution dès que la valeur 5 est rencontrée.\nx = 0 TANT QUE x \u0026lt; 10 ALORS ajoute un à x SI x == 5 ALORS TERMINE FIN TANT QUE AFFICHE x La valeur x ne sera donc jamais affichée.\nIl arrive aussi qu'un pseudo-code doit retourner une valeur. Par convention, dès que la valeur attendue est retournée, l'algorithme prend fin. Ainsi donc, dans le cas suivant, la valeur 5 sera retournée.\nx = 0 TANT QUE x \u0026lt; 10 ALORS ajoute un à x SI x == 5 ALORS RETOURNE x FIN TANT QUE RETOURNE x Exécution d'un pseudo-code Pour comprendre un pseudo-code que vous venez de recevoir, ou pour tester un pseudo-code que vous venez de créer, il est essentiel de l'exécuter. Quand on exécute un pseudo-code, on se contente de lire les consignes logiques.\nPrenons un exemple: Variable test = 0 TANT QUE test \u0026lt; 100 test = test + 22 FIN TANT QUE retourne test Je débute le pseudo-code avec la valeur 0 stockée dans la variable test. J'entre dans la boucle TANT QUE. J'ajoute 22 à la variable test, le résultat est 22. J'entre dans la boucle TANT QUE. J'ajoute 22 à la variable test, le résultat est 44. J'entre dans la boucle TANT QUE. J'ajoute 22 à la variable test, le résultat est 66. J'entre dans la boucle TANT QUE. J'ajoute 22 à la variable test, le résultat est 88. J'entre dans la boucle TANT QUE. J'ajoute 22 à la variable test, le résultat est 110. Je quitte la boucle TANT QUE. Je retourne la valeur stockée dans la variable test, soit 110. Vous devez absolument être capable de faire de telles exécutions. Dans certains cas, votre pseudo-code va dépendre de paramètres: il faut alors exécuter le pseudo-code plus d'une fois, sur plusieurs cas de test. Dans certains cas, le pseudo-code peut prendre trop d'étapes pour qu'un humain puisse l'exécuter entièrement : vous devriez au moins en faire une partie.\nLes problèmes difficiles Dans ce cours d'introduction à la programmation, vous n'aurez pas à résoudre des problèmes difficiles sur le plan algorithmique. C'est-à-dire que, le plus souvent, si vous maîtrisez bien la programmation et les mathématiques, la conception de l'algorithme ne sera pas un obstacle.\nIl faut savoir que ce n'est pas toujours le cas. Un petit nombre de problèmes rencontrés dans des situations réelles sont difficiles. Il est, par exemple, difficile de créer une intelligence artificielle capable de jouer aux échecs aussi bien que les grands maîtres. Parfois, même quand l'algorithme est facile à concevoir, mettre en oeuvre une solution efficace peut être très difficile. Il est difficile d'optimiser le chemin que doit suivre un livreur qui a plusieurs livraisons à faire sans devoir énumérer toutes les possibilités. Encore une fois, dans le contexte de ce cours, nous n'exigerons pas que vos solutions soient particulièrement efficaces.\nLecture suggérée : Problème du voyageur de commerce Vidéos suggérées Erreurs communes Rédiger du pseudo-code n'a rien de sorcier, mais plusieurs étudiants font des erreurs. Voici quelques erreurs communes.\nCertains étudiants rédigent du pseudo-code qui a l'air formel et correct, mais qui est en fait ambigu et inutilisable. Prenons cet exemple: SI j'ai mal aux dos ALORS je prend des aspirines OU SI j'ai faim ALORS je mange Bien sûr, je n\u0026rsquo;ai utilisé que des expressions logiques. Des SI, des ALORS des OU. Mais qu\u0026rsquo;est-ce que ça signifie ? Par exemple, est-ce que je peux à la fois manger et prendre des aspirines dans ce scénario ? La réponse est subjective.\nVotre pseudo-code doit être exécutable sans interprétation. Un pseudo-code n\u0026rsquo;est pas un texte à interprétation subjective.\nVous ne pouvez pas faire semblant d\u0026rsquo;écrire du pseudo-code en utilisant simplement les termes qu\u0026rsquo;on trouve fréquemment au sein des pseudo-codes. Ce n\u0026rsquo;est pas une question de syntaxe. On peut parfaitement écrire du pseudo-code sans jamais utiliser SI, TANT QUE, etc. Plusieurs étudiants obsèdent sur la syntaxe, croyant à tort que si on leur donne les bons termes, la bonne grammaire, ils trouveront comment comprendre ce qu\u0026rsquo;est un pseudo-code. Or, c\u0026rsquo;est justement le contraire de la leçon ici: nous voulons que vous compreniez que la syntaxe exacte est secondaire dans la pensée algorithmique.\nSi vous avez fait vos mathématiques du collégial, vous avez appliqué maintes et maintes fois des algorithmes formels, en commençant par la division longue. Vous savez diviser 321321 par 13, n\u0026rsquo;est-ce pas ? Pour y arriver, vous utilisez un algorithme complexe (plus complexe que ce qu\u0026rsquo;on vous demande de concevoir dans ce cours). Or il n\u0026rsquo;y a pas besoin d\u0026rsquo;avoir une syntaxe particulière pour expliquer l\u0026rsquo;algorithme de la division longue. On peut l\u0026rsquo;expliquer en des termes parfaitement naturels en français.\nAu bout du compte, si vous n\u0026rsquo;arrivez pas à exprimer des algorithmes simples en français, de manière précise, il ne sert à rien d\u0026rsquo;essayer d\u0026rsquo;apprendre à programmer en Java, en C# ou en Python. Il y a une compétence basique que vous devez avoir développée préalablement. Vous devez être capable de comprendre et de rédiger des consignes simples et claires (non subjectives). Si vous arrivez à faire des probabilités et de l\u0026rsquo;algèbre linéaire, vous devez avoir acquis une certaine pensée formelle. Nous vous demandons ici d\u0026rsquo;appliquer cette compétence de logique et de raisonnement formel. La syntaxe est secondaire. Il faut que vous puissiez être clair dans vos consignes peu importe les termes que vous utilisez.\nOn peut être imprécis et incohérent en utilisant une syntaxe formelle, et on peut être précis et cohérent en utilisant du français usuel. Ce n\u0026rsquo;est pas parce que vous utilisez des expressions qui vous semblent précises que vous l\u0026rsquo;êtes. Vous devez avoir une idée précise en tête et vous devez l\u0026rsquo;exprimer avec précision.\nAu sein d'une boucle (par ex., TANT QUE), les étudiants peuvent mettre par erreur une condition qui termine toujours le programme. Dans un tel cas, la boucle ne peut pas s'exécuter et elle est de facto brisée. Voici un exemple: Variable iterateur (entier) Variable minimum = tableau[0]\niterateur = 0 TANT QUE iterateur \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS retourner tableau[iterateur]; SINON retourner minimum FIN SI iterateur = iterateur + 1; FIN TANT QUE Les instructions « retourner minimum » et « retourner tableau[iterateur];» terminent le pseudo-code.\nAssurez-vous de bien comprendre que ce pseudo-code ne va consulter que la première valeur du tableau. Si vous avez une condition ou les deux branches (SI et SINON) retournent une valeur et terminent donc l\u0026rsquo;algorithme, votre algorithme ne procèdera pas plus loin. Certains étudiants construisent des boucles qui ne se terminent jamais. Dans une boucle TANT QUE, il faut s'assurer que la condition ne soit plus satisfaite pour ne pas avoir une boucle infinie. Consultez cet exemple : iterateur = 0 TANT QUE iterateur \u0026lt; 100 FAIRE SI iterateur \u0026lt; 10 ALORS ajouter un à itérateur FIN SI FIN TANT QUE Si vous testez votre pseudo-code, vous saurez éviter de telles erreurs.\nLes étudiants vont aussi fréquemment utiliser des variables et des constructions qui ne sont pas définies et dont le sens doit être deviné. Voici un exemple: Entier iterateur[tableau] = 0; TANT QUE iterateur[i] \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS retourner iterateur[tableau]; FIN SI iterateur = iterateur[tableau] + 1; FIN POUR TOUT Vous constaterez à la lecture de ce pseudo-code qu'il y a plusieurs conventions syntaxiques qui ne sont pas définies. Il y a plusieurs variables, mais il est difficile de connaître leur type et leurs relations. Assurez-vous donc de bien expliquer chaque variable et de bien définir votre syntaxe. Dans ce dernier exemple, que représente iterateur, iterateur[tableau], tableau[iterateur], etc.? Vous devez être précis. Souvent, nous avons un nombre limité de « types » pour les variables: nombres, entiers, chaînes de caractères. Il convient, pour chaque variable, d'en préciser le type. Nous avons aussi des tableaux. On utilise le plus souvent la convention t[i] pour désigner l'élément à l'index i du tableau t. Dans un tel cas, t doit être un tableau, i doit être une valeur entière. Vous être libre de concevoir vos propres conventions, mais vous devez être explicite et précis.\nSi votre pseudo-code doit retourner une valeur, il faut que le pseudo-code le spécifie explicitement.\nSi vous avez bien défini le type de vos variables, et toutes vos conventions syntaxiques, il vous reste maintenant à vous assurer que les valeurs de vos variables sont toujours spécifiées. Si vous dites que x est un nombre et que vous posez ensuite l'inéquation x \u003e 1, nous ne pouvons en connaître la valeur que si x a reçu une valeur. Assurez-vous donc de donner une valeur initiale à toutes vos variables. En tout temps, dans votre pseudo-code, le lecteur doit pouvoir déterminer la valeur d'une variable donnée. Parfois les étudiants manquent tout simplement de rigueur. Pour vérifiez si votre pseudo-code est rigoureux, appliquez-le sur un exemple concret comme si vous étiez un robot. Par exemple, si quelqu'un écrit le pseudo-code suivant « je prend chacune des valeurs du tableau, et je l'additionne à la valeur suivante dans le tableau »... vous pourriez alors prendre un tableau à titre d'exemple, comme [1,2,3] et tester l'instruction. Qu'est-ce que ça donnerait ? Je prend les valeurs une à une et je l'additionne à la valeur suivante dans le tableau. Je prend donc 1 et sa valeur suivante (1 + 2), ensuite 2 et sa valeur suivante (2 + 3), et ensuite 3 et sa valeur suivante... ? Je me rend compte que l'expression « la valeur suivante » n'est pas bien définie. Voici un autre exemple. Quelqu'un pourrait avoir comme pseudo-code « j'initialise la variable comme ayant comme valeur le premier élément du tableau ». Testons ce pseudo-code sur le tableau vide (de taille zéro). Nous constatons qu'il n'y a pas de premier élément ! Donc si le tableau vide n'est pas exclu, nous avons un problème de rigueur. Voici un truc: testez toujours votre pseudo-code avec plusieurs exemples concrets. Prenez le temps d'appliquer les instructions de votre pseudo-code ligne par ligne, comme si vous étiez un robot. Pensez comme un ordinateur! Nous vous invitons maintenant à passez aux premiers exercices du cours!\n"},{"id":28,"href":"/inf1901-teluq/docs/modules/module5/","title":"Module 5. La programmation orientée-objet: héritage et le polymorphisme","section":"Modules","content":" Module 5 # Le module 5 initie à la programmation orientée objet en explorant deux concepts fondamentaux : l’héritage et le polymorphisme. L’héritage permet de créer des classes dérivées qui réutilisent et étendent les propriétés et comportements de classes existantes, favorisant ainsi une conception modulaire et efficace du code. Le polymorphisme, quant à lui, offre la possibilité d’utiliser des objets de différentes classes de manière uniforme, en s’appuyant sur des interfaces ou des classes parentes. À travers des exemples pratiques issus du manuel Java pas à pas et du site du cours, ce module enseigne comment appliquer ces principes pour construire des programmes Java structurés, flexibles et maintenables.\nCe module met également en lumière l’importance de ces concepts dans la résolution de problèmes complexes. Les apprenants découvrent comment organiser le code en hiérarchies de classes pour modéliser des relations du monde réel, tout en utilisant le polymorphisme pour écrire des fonctions génériques et adaptables. Les exercices pratiques permettent de manipuler des classes abstraites, des interfaces et des méthodes surchargées, renforçant la compréhension des mécanismes de la programmation orientée objet. En s’appuyant sur les acquis des modules précédents, ce module consolide les compétences nécessaires pour concevoir des solutions logicielles robustes et évolutives, prêtes à répondre à des besoins variés.\n"},{"id":29,"href":"/inf1901-teluq/docs/ressources/","title":"Ressources","section":"Docs","content":" Ressources pour apprendre Java # Ce document regroupe des ressources variées pour apprendre Java, des livres aux tutoriels en ligne, en passant par des vidéos et des conseils pratiques. Il s’adresse aux débutants comme aux apprenants intermédiaires souhaitant approfondir leurs compétences en programmation.\nOuvrages de référence # Les livres suivants offrent une introduction ou un approfondissement en Java, adaptés à différents niveaux :\nClaude Delannoy, Programmer en Java, Eyrolles : un ouvrage complet pour les débutants et intermédiaires. Barry Burd, Java pour les nuls, 4e édition (environ 25 $) : une approche conviviale, idéale pour les novices. Cyrille Herby, Apprenez à programmer en Java (environ 11 $) : un manuel axé sur la programmation professionnelle. Documentation officielle # La documentation d’Oracle est une référence incontournable pour comprendre les bases et explorer les fonctionnalités avancées :\nTutoriel officiel d’Oracle (en anglais) : une introduction progressive aux concepts fondamentaux.\nhttps://docs.oracle.com/javase/tutorial/ API Java 8 : une documentation détaillée pour cette version stable et largement utilisée.\nhttps://docs.oracle.com/javase/8/docs/api/ API Java 24 : la version la plus récente, incluant les dernières évolutions du langage.\nhttps://docs.oracle.com/en/java/javase/24/docs/api/ Guides en ligne # Les ressources numériques gratuites permettent un apprentissage autonome et flexible :\nSébastien Combéfis, Apprendre Java et la programmation orientée objet : un cours structuré pour débutants.\nhttps://www.ukonline.be/cours/java/apprendre-java Programmation Java sur Wikibooks : un guide collaboratif couvrant les bases et des sujets avancés.\nhttps://fr.wikibooks.org/wiki/Programmation_Java Stack Overflow : une plateforme pour poser des questions ou trouver des solutions à des problèmes concrets.\nhttps://stackoverflow.com/ Vidéos pédagogiques # YouTube propose des séries en français pour apprendre Java de manière visuelle :\nCours d’introduction à Java par FormationVideo : une série appréciée pour son approche claire.\nhttps://www.youtube.com/playlist?list=PLrSOXFDHBtfHkq8dd3BbSaopVgRSYtgPv Apprendre le Java : une série complète pour découvrir les bases.\nhttps://www.youtube.com/playlist?list=PLMS9Cy4Enq5LKYxJmD1ZIu3C7f3vA00hM Tuto Java : des explications simples pour progresser rapidement.\nhttps://www.youtube.com/playlist?list=PLBNheBxhHLQxfJhoz193-dRwvc2rl8AOW Java apprendre à coder : une approche pratique pour les débutants.\nhttps://www.youtube.com/playlist?list=PLvWq8NyUnHacq2hJ7S4FKhaQGN3xotKb7 Programmer en Java : des vidéos détaillées pour approfondir ses compétences.\nhttps://www.youtube.com/playlist?list=PLlxQJeQRaKDRnvgIvfHTV6ZY8M2eurH95 Conseils pour apprendre efficacement # Aucune ressource unique ne suffit pour maîtriser la programmation. Voici une approche recommandée :\nCommencez par un livre ou un tutoriel adapté à votre niveau pour poser des bases solides. Consultez la documentation officielle pour des précisions techniques sur des points spécifiques. Utilisez les vidéos pour visualiser les concepts et clarifier les notions abstraites. Pratiquez régulièrement avec des exercices ou des petits projets pour ancrer vos connaissances. En cas de blocage, Stack Overflow ou les forums de cours peuvent fournir des solutions concrètes. L’apprentissage de la programmation suit un processus itératif. Revisitiez les mêmes notions à travers différentes ressources (livres, vidéos, guides) pour consolider votre compréhension. Explorez au-delà des ressources proposées, car la recherche autonome est essentielle pour progresser. Par exemple, un manuel ne peut remplacer la pratique, tout comme un tutoriel vidéo ne suffit pas sans exercices. Adoptez une approche variée et persévérante.\n"},{"id":30,"href":"/inf1901-teluq/docs/modules/module3/travail-note-3/","title":"Travail noté 3","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":31,"href":"/inf1901-teluq/docs/modules/module3/activite-3-4/","title":"Activité 3.4","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":32,"href":"/inf1901-teluq/docs/modules/examen/","title":"Examen","section":"Modules","content":" "},{"id":33,"href":"/inf1901-teluq/docs/modules/module2/exercices-2-2/","title":"Exercices 2.2","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":34,"href":"/inf1901-teluq/docs/modules/module1/exercices/","title":"Exercices sur les algorithmes","section":"Module 1: Algorithme et pseudocode","content":" Exercices sur les algorithmes et problèmes # La notion d\u0026rsquo;algorithme a été abordée implicitement dès les premiers cours de mathématiques, par exemple avec l\u0026rsquo;algorithme de la division longue. Ces exercices visent à vous faire décrire formellement un algorithme. La principale difficulté pour la plupart des étudiants réside dans la rigueur et la précision requises. Au-delà d’un certain point, il n’existe pas de lectures supplémentaires : la pratique est essentielle.\nIl est permis d’utiliser le robot conversationnel du cours pour ces exercices (voir ici). Toutefois, entraînez-vous à produire vos propres réponses.\nComment procéder pour les exercices :\nLisez attentivement la question. Cherchez une solution. Si vous ne trouvez pas immédiatement, consacrez 10 à 15 minutes à y réfléchir. Si le problème exact vous résiste, tentez une solution partielle. Pour cet exercice, vous devez produire du pseudo-code, et non du Java. Rédigez votre solution avec précision, comme une suite de consignes qu’un enfant pourrait suivre. Exécutez votre pseudo-code (voir l’exécution d’un pseudo-code à l’activité 1.2). Consultez ensuite la ou les solutions proposées. Assurez-vous de comprendre toutes les solutions. Posez des questions si nécessaire, en fournissant votre propre solution pour appuyer vos interrogations. Comprendre les solutions proposées est impératif. Ces exercices sont obligatoires et ne doivent pas être survolés ou omis.\nPour lire les formules mathématiques sur le site du cours, utilisez un navigateur compatible avec MathML, comme Firefox ou Safari.\nCes exercices sont conçus pour l’autoévaluation ; ils ne sont pas corrigés. Nous répondons cependant à vos questions sur la matière.\nLes solutions à ces exercices ne sont pas uniques. Il existe plusieurs syntaxes possibles pour décrire un algorithme en pseudo-code. Cela ne signifie pas que toutes les solutions sont correctes. Un pseudo-code peut être erroné s’il ne décrit pas une solution logiquement correcte ou s’il manque de précision pour être considéré comme un algorithme. Un pseudo-code doit pouvoir être exécuté littéralement par un humain sans jugement, comme un automate.\nRappel : les mathématiques du collégial sont un préalable obligatoire à ce cours. Une aisance en algèbre, fonctions et arithmétique est nécessaire. Sans ces prérequis, réussir ce cours peut être difficile.\nRéponses uniques ? # Les exercices incluent une solution pour comparer votre approche à la nôtre. Il n’existe pas de solution unique ; votre solution peut être meilleure ou moins bonne que celle proposée.\nExercice 1 : La somme d’un tableau # Dans la plupart des langages informatiques, un tableau correspond à un vecteur en algèbre linéaire, soit une série de nombres, comme \u0026lt;1,6,4,10\u0026gt;. Dans cet exercice, vous devez proposer un algorithme pour calculer la somme des nombres entiers d’un tableau à une dimension de longueur quelconque (de 0 à plus d’un million de nombres). Utilisez une structure d’itération (boucle) pour parcourir chaque nombre du tableau.\nPour manipuler le tableau, vous pouvez écrire « Récupérer le nombre à l’index i » (où i est une variable contenant l’index) ou utiliser une syntaxe proche des langages de programmation, par exemple : Entier e = monTableau[i]. Pour obtenir la longueur du tableau, utilisez « la taille de monTableau ».\nTestez votre pseudo-code en l’appliquant ligne par ligne à un exemple, comme si vous étiez un robot. Prenez votre temps.\nSi vous introduisez d’autres conventions de notation, soyez précis. Spécifiez le type de toutes vos variables et donnez explicitement des valeurs initiales, sauf si elles sont reçues en paramètre.\nConcevez cet algorithme en pseudo-code, en utilisant des termes concis, explicatifs et cohérents.\nRéponse Entrée : Tableau d’entiers monTableau de taille N Variables : Entier somme = 0 // La somme du tableau Entier index = 0 // Index de l’élément du tableau Sortie : Entier somme Algorithme sommeTableau : TANT QUE index \u0026lt; taille de monTableau FAIRE somme = somme + monTableau[index] // Addition des nombres index = index + 1 // Incrémentation de l’index FIN TANT QUE retourne somme Exercice 2 : La recherche d’un entier # La recherche d’information dans une structure de données (tableau, graphe, arbre, etc.) est un domaine clé en informatique. Bien que les bases de données comme MySQL simplifient la recherche, il est souvent nécessaire de concevoir ses propres solutions. À partir de l’exercice 1, proposez un algorithme en pseudo-code pour vérifier si un entier (par exemple, un numéro de téléphone) est présent dans un tableau et retourner son index, ou -1 s’il est absent. Utilisez une structure itérative et une structure de contrôle (SI _ ALORS _ FINSI).\nRéponse Entrée : Tableau d’entiers monTableau de taille N Entier nombreATrouver Variables : Entier index = 0 // Index de l’élément du tableau Sortie : Index de l’entier ou -1 si non trouvé Algorithme trouverEntier : TANT QUE index \u0026lt; taille de monTableau FAIRE SI nombreATrouver est égal à monTableau[index] ALORS retourner index // Fin de l’algorithme FIN SI index = index + 1 // Incrémentation de l’index FIN TANT QUE retourner -1 // Nombre non trouvé Exercice 3 # Additionnez tous les nombres naturels inférieurs à 1000 qui sont multiples de 3 ou de 5.\nRéponse Voici un algorithme inefficace. Vous pouvez faire mieux :\nVariable entière i = 0 Variable entière somme = 0 TANT QUE i \u0026lt; 1000 SI le reste de la division par 3 de i est zéro OU le reste de la division par 5 de i est zéro ALORS somme = somme + i i = i + 1 FIN TANT QUE Retourne somme Exercice 4 # Trouvez le plus grand nombre premier qui divise 317584931803.\nRéponse Voici un algorithme inefficace (effectuant plus d’opérations que nécessaire). Vous pouvez faire mieux :\nVariable entière i = 1 Variable entière solution = 1 TANT QUE i \u0026lt; 317584931803 SI le reste de la division de 317584931803 par i est zéro ALORS Variable entière j = 3 Variable booléenne premier = vrai TANT QUE j \u0026lt; i SI le reste de la division de i par j est zéro ALORS premier = faux j = j + 1 FIN TANT QUE SI premier ALORS solution = i i = i + 1 FIN TANT QUE Retourne solution Pour les curieux, voici une solution exécutable en Python (voir ici) :\ni = 1 solution = 1 while i \u0026lt; 317584931803: if 317584931803 % i == 0: j = 3 premier = True while j \u0026lt; i: if i % j == 0: premier = False j = j + 1 if premier: print(i, \u0026#34; est premier\u0026#34;) solution = i i = i + 1 print(solution) Vous pouvez supprimer la ligne print(i, \u0026quot; est premier\u0026quot;) pour n’obtenir que la réponse finale. Notez que j commence à 3, car tout diviseur premier (sauf 2) est impair d’après le théorème fondamental de l’arithmétique.\nExercice 5 # Pour un entier positif x, trouvez le chiffre occupant la position des dizaines.\nRéponse Variable entière x Divise x par 10, stocke le quotient dans la variable y Divise y par 10, retourne le reste de la division Exemple : si x est 531, le quotient de 531 divisé par 10 est 53, reste 1. Le quotient de 53 divisé par 10 est 5, reste 3.\nExercice 6 # Trouvez l’erreur dans le pseudo-code suivant :\nEntrées : Tableau R de longueur N Valeur X Sortie : Est-ce que la valeur X se trouve dans le tableau R ? Variables : Itérateur i = 0 Tant que i \u0026lt;= N Si R[i] = X Alors retourne Vrai i = i + 1 retourne Faux Réponse L’itérateur i prend les valeurs de 0 à N, accédant ainsi à N+1 éléments du tableau R, ce qui provoque une erreur d’accès hors limites.\nExercice 7 # Soit P(x) = ax² + bx + c un polynôme du second degré à coefficients réels. Les racines se calculent via le discriminant A = b² - 4ac.\nSi A \u0026lt; 0, il n’y a pas de racine. Si A \u0026gt; 0, il existe deux racines : X1 = (-b - √A)/(2a) et X2 = (-b + √A)/(2a). Si A = 0, il existe une racine double : X1 = X2 = -b/(2a). Écrivez un algorithme qui, pour un polynôme donné par ses coefficients, calcule le discriminant, affiche « ce polynôme n’a pas de racine dans R » si A \u0026lt; 0, et calcule les racines sinon.\nRéponse Algo pol Entrée : Nombres réels a, b, c // Coefficients du polynôme Variables : Nombres réels X1, X2, A // Racines et discriminant Début A = b² - 4ac Si A \u0026lt; 0 Alors Afficher « ce polynôme n’a pas de racine dans R » Sinon Si A égale 0 X1 = X2 = -b/(2a) Sinon // A \u0026gt; 0 X1 = (-b - √A)/(2a) X2 = (-b + √A)/(2a) Fin Si Fin Si Fin Exercice 8 # Exécutez l’algorithme de l’exercice 7 pour P(x) = x² - 5x + 6, en présentant les résultats dans un tableau.\nRéponse Initialisation Étape 1 Étape 2 Étape 3 Fin Entrée a 1 1 1 1 1 b -5 -5 -5 -5 -5 c 6 6 6 6 6 Variables X1 2 2 2 X2 3 3 A 1 1 1 1 Sorties écran Exercice 9 # Pour un entier B \u0026gt; 1 et un nombre M, la représentation en base B de M s’obtient par division successive : M = B × Q₁ + R₁, puis Q₁ = B × Q₂ + R₂, jusqu’à un quotient inférieur à B. La représentation est Qₙ₋₁Rₙ…R₁. Si B \u0026gt; 10, les chiffres de 10 à B-1 sont notés A, B, C, etc. (par exemple, pour B = 16, 10 = A, 11 = B, etc.).\nÉcrivez un algorithme pour convertir un nombre M dans une base B ≥ 2 (B \u0026lt; 17). Affichez un message d’erreur si B \u0026lt; 2.\nRéponse Algo base Entrée : Nombre entier positif B // Base Nombre entier positif M // Nombre à convertir Variables : Nombre entier q, r Suite de caractères alphanumériques S Début S = chaîne vide Si B \u0026lt; 2 Alors Afficher « entrez un entier supérieur ou égal à 2 » Sinon q = M Tant que q \u0026gt; 0 r = q - (q ÷ B) × B au cas où r égal à 10 : ajouter A au début de S égal à 11 : ajouter B au début de S égal à 12 : ajouter C au début de S égal à 13 : ajouter D au début de S égal à 14 : ajouter E au début de S égal à 15 : ajouter F au début de S dans tous les autres cas : ajouter r au début de S q = q ÷ B Fin Tant que Fin Si Fin Voici l’équivalent en Python (voir ici) :\ndef f(M, B): s = \u0026#34;\u0026#34; if B \u0026lt; 2: print(\u0026#34;entrez un entier supérieur ou égal à 2\u0026#34;) return q = M while q \u0026gt; 0: r = q - (q // B) * B if r == 10: s = \u0026#34;A\u0026#34; + s elif r == 11: s = \u0026#34;B\u0026#34; + s elif r == 12: s = \u0026#34;C\u0026#34; + s elif r == 13: s = \u0026#34;D\u0026#34; + s elif r == 14: s = \u0026#34;E\u0026#34; + s elif r == 15: s = \u0026#34;F\u0026#34; + s else: s = str(r) + s q = q // B return s Exercice 10 # En utilisant l’algorithme Algo_base, qui retourne la représentation en base B d’un nombre M (S = Algo_base(B, M)), écrivez un algorithme qui teste la parité d’un nombre M et affiche « pair » ou « impair ».\nRéponse Algo parité Entrée : Nombre entier positif M // Nombre à tester Variables : Suite de caractères alphanumériques S Début S = Algo_base(2, M) Si dernier caractère de S est égal au chiffre 0 Alors Afficher « pair » Sinon Afficher « impair » Fin Si Fin Problèmes supplémentaires # Ce cours se concentre sur les bases de l’algorithmique et du pseudo-code. Si vous avez sérieusement résolu les exercices précédents, vous êtes prêt. Voici toutefois des problèmes supplémentaires :\nDans un tableau, vérifiez si le nombre 3 est immédiatement suivi du nombre 2. Pour un tableau donné, vérifiez s’il est trié en ordre croissant. Pour deux entiers positifs a et b, comptez les entiers dans l’intervalle [a, b] divisibles par 3. Des vidéos sur l’algorithmique et le pseudo-code sont disponibles, comme celles de Loïc \u0026amp; Julien (voir ici) ou d’autres auteurs.\nCertains étudiants utilisent des logiciels comme AlgoBox (voir ici). Cela n’est pas nécessaire, car le pseudo-code doit être écrit dans vos propres mots. Si un logiciel vous aide, utilisez-le, mais vous devriez pouvoir écrire du pseudo-code manuellement, sans outils. C’est l’essence du pseudo-code : il est indépendant des syntaxes et des outils.\n"},{"id":35,"href":"/inf1901-teluq/docs/modules/module3/activite-3-5/","title":"Activité 3.5","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" "},{"id":36,"href":"/inf1901-teluq/docs/evaluation/","title":"Évaluation","section":"Docs","content":"Évaluation Ce cours compte 5 travaux notés à remettre au cours des 15 semaines et d'un examen final à réaliser à la fin du cours. Voici la grille de pondération des travaux :\nÉvaluations Sujets Travail Noté #1 Les algorithmes Travail Noté #2 Types, opérateurs et méthodes Travail Noté #3 Structures de contrôle, itérations et données Travail Noté #4 Les flux d'entrée et de sortie Travail Noté #5 Héritage et polymorphismes Examen L'ensemble du cours Avant de faire les travaux, il faut avoir fait les lectures et les exercices de préparation. Essayez d'aller directement aux travaux notés est une stratégie perdante pour la plupart des étudiants. Prenez le temps d'étudier la matière! Dans tous les cas, vous devez expliquer vos solutions. Les travaux notés sont des travaux individuels. Vous devez les réaliser seul. Le professeur ne donne pas d'indice, à quiconque: il est inutile d'en demander. "},{"id":37,"href":"/inf1901-teluq/docs/modules/module1/travail-note-1/","title":"Travail noté 1","section":"Module 1: Algorithme et pseudocode","content":"Travail noté 1 - Les algorithmes Prenez le temps de lire les consignes. Nous expliquons toute la démarche en détail, en répétant même plus d'une fois les informations importantes pour être sûr que tout est clair et limpide.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des travaux notés. Cependant vous devez produire vos propres réponses et vos propres analyses.\nDans ce cours, nous visons à corriger les travaux dans les cinq jours ouvrables suivant leur dépôt. Si vous n'avez pas reçu la correction après 10 jours ouvrables, vous pouvez joindre le professeur pour voir où nous en sommes avec la correction. Tenez cependant compte du fait que nos correcteurs prennent souvent des vacances durant l'été et pendant la période des fêtes de Noël.\nSuite à la correction, vous trouverez dans le portail étudiant un document expliquant votre note. Vous devez vous rendre sur le portail étudiant afin de recevoir cette rétroaction. Nous ne transmettons pas la rétroaction et les notes pour courriel. Vous devez vous rendre sur le portail pour consulter votre note et pour consulter la rétroaction.\nÉvidemment, comme il y a un délai dans la correction, si vous remettez vos travaux à la toute fin du cours, il est possible que vous deviez passer l'examen sans avoir obtenu de rétroaction sur vos travaux: planifiez votre travail en conséquence!\nImportant: En commençant, prenez en note la date de fin de cours. Vous devez avoir remis les travaux d'ici cette date. Si vous avez besoin d'un report de la date de fin de cours, peut-être à cause d'empêchements médicaux ou familiaux, vous devez joindre l'Université (pas le professeur) pour établir votre situation et obtenir un report. Vous ne pouvez pas obtenir un report après la date de fin de cours. Le professeur ne peut modifier votre date de fin de cours.\nAmpleur des travaux Dans ce cours, le niveau de difficulté et le travail nécessaire pour compléter les travaux est comparable à ce que nous trouvons au sein des autres universités pour un cours d'introduction à la programmation. Vous devez prévoir plusieurs heures pour compléter chaque travail. Selon votre préparation préalable et vos aptitudes à la programmation, le temps nécessaire pour chaque activité peut varier. Néanmoins, vous devez prévoir une charge de travail de neuf heures par semaine pendant quinze semaines.\nLisez bien, testez et relisez-vous Les travaux notés testent en partie votre capacité à comprendre des énoncés logiques. Vous devez lire de manière attentive les consignes et les questions, et vous devez montrer que vous êtes capable de les interpréter et de faire preuve de raisonnement abstrait. Un programmeur doit être à même de lire un énoncé logique et de le traduire en pseudo-code sans qu'on doive lui donner des exemples ou lui expliquer l'énoncé.\nL'erreur la plus commune faite par les étudiants et de supposer que parce qu'ils ont pu produire une solution, elle doit être soit correcte, soit suffisamment correcte. Ce qui distingue les étudiants qui apprennent vraiment à programmer des autres ce sont les tests. Prenez le temps de vous relire, d'analyser vos solutions, d'exécutez le code dans votre tête. Encore et encore. Passez du temps sur vos solutions pour vous assurez que vous avez tout prévu et tout compris. Programmer ne se fait pas à grande vitesse. Il faut être patient et prudent. Prenez le temps de vous expliquer. Vous devriez utiliser plus d'espace dans vos travaux à analyser et expliquer qu'à reproduire du code.\nVoici une règle d'or : Vous devez passer plus de temps à vérifier votre solution qu'à la produire.\nCorrection des travaux Certains étudiants sont surpris par leurs notes quand après avoir rédigé plusieurs pages de documentation afin de répondre à une question, ils obtiennent une note de zéro. Bien que nous apprécions les efforts des étudiants, vos réponses doivent être correctes pour recevoir des points. Il peut, bien sûr, y avoir des coquilles ou imprécisions dans vos travaux : rien n'est jamais parfait. Par contre, nous ne donnons pas de points « pour l'effort ». Il est donc important pour vous d'arriver essentiellement à la réponse recherchée. Assurez-vous donc que vos réponses sont aussi claires que possible.\nLes reports de la date de fin de cours Rappel: le professeur ne peut pas modifier votre date de fin de cours peu importe votre situation. Le moment après la date de fin de cours où votre dossier est fermé et où vous recevez (éventuellement) un incomplet est géré par l'Université. Il est de votre responsabilité de bien planifier votre temps. Si vous n'avez pas d'expérience en programmation, prévoyez neuf heures de travail pendant quinze semaines pour compléter le cours. Il est impératif de faire les exercices et les lectures. L'étudiant moyen ne peut réussir ce cours en ne faisant que les travaux notés. Si vous avez des problèmes personnels qui limitent vos progrès (maladie, deuil, etc.), il faut voir avec l'Université: les professeurs n'ont aucune prise sur les dates de fin, sur les dates d'examen, etc.\nVotre date de fin de cours est inscrite dans votre dossier et vous pouvez la trouver sur le portail étudiant et sur la documentation qu'on vous a remise lors de votre inscription. Il est possible que votre examen ait lieu des semaines ou même des mois après votre date de fin de cours: cela ne constitue pas une extension de votre date de fin de cours. Tout travail remis après votre date de fin de cours pourra recevoir la note de zéro. En tout temps, la note « incomplet » peut être attribuée à un travail qui n'est pas remis après votre date de fin de cours, même si vous n'avez pas encore passé l'examen.\nInstructions de dépôt du travail notés : Vous devez remettre le fichier pdf contenant votre travail sur le site de dépôt des travaux de la TÉLUQ : http://www.teluq.ca/depot-travaux-etudiant\nIl n'y a pas de gabarit ou de modèles pour la mise en forme des travaux notés, mais vous devriez utiliser le sens commun. Rédigez un document lisible, incluez votre nom, le titre du cours et son sigle, identifiez clairement le travail noté. Ne prenez pas en photo un manuscript: rédigez plutôt votre travail en utilisant un traitement de texte ou l'équivalent. Vous pouvez inclure des diagrammes, mais vos explications doivent prendre la forme de prose suivie en français correct. Écrivez des phrases complètes qui débutent par une majuscule et se terminent par un point. Si vous avez du mal avec le français, n'hésitez pas à utiliser un correcteur grammatical comme Antidote. Si nous avons du mal à vous lire, vous pourriez obtenir une note de zéro.\nAttention: une fois le travail remis dans l'outil de dépôt, vous ne pourrez pas le modifier. Vérifiez bien votre travail avec soin avant de le remettre. Relisez-vous deux fois plutôt qu'une.\nAvant de faire le travail, assurez-vous d'avoir fait tous les exercices et toutes les lectures. Posez des questions au besoin. Ne commencez le travail que lorsque vous êtes certain de bien maîtriser la matière. Il n'y a pas de lectures à faire dans le manuel pour ce travail: les notes de cours en ligne, ainsi que les activités qu'elles comprennent suffisent. Néanmoins, il faut bien lire et bien se préparer.\nUne trop grande fraction des étudiants font les travaux notés sans avoir fait au préalable sérieusement les exercices préparatoires.\nVous ne pouvez remettre le travail qu'à partir de votre date de début de cours. Par ailleurs, après votre date de fin de cours, vous ne pourrez plus remettre de travaux. Votre date de fin de cours vous a été annoncée lors de votre inscription et se trouve sur le portail étudiant. Si vous n'arrivez pas à retrouver votre date de fin de cours, consultez l'Université (ce n'est pas le professeur qui fixe cette date). Votre date de fin de cours n'est pas la date à laquelle vous passez votre examen. Votre date de fin de cours ne peut pas être négociée avec le professeur. En aucun cas est-ce que vous devriez demander au professeur la permission de remettre vos travaux après votre date de fin de cours: il est de votre responsabilité de remettre vos travaux à temps.\nDans ce cours, vous pouvez remettre vos travaux à tout moment entre votre date de début de cours et votre date de fin de cours. Il est possible que l'on vous suggère des dates de remises au sein notamment du portail étudiant. Ces dates sont des suggestions afin de vous aider à gérer votre temps.\nOn vous encourage à faire des recherches sur Internet pour compléter ce travail, au besoin.\nSi vous avez des questions sur le travail, vous pouvez communiquer avec le professeur responsable. Si vous écrivez au professeur, ajoutez [INF1220] dans l'objet de votre message ainsi que tout autre détail nécessaire afin de bien situer votre question. Attention: nous ne donnons jamais d'indice (à quiconque) sur les travaux notés au-delà de ce qui est déjà dans l'énoncé (ce serait inéquitable).\nRappel, rappel, rappel: Vous devez déposer le travail dans l'outil de dépôt. N'envoyez pas votre travail par courriel. Vous ne pouvez utiliser l'outil de dépôt qu'après le début de votre cours et avant la fin de votre cours, et seulement si vous avez été inscrit au cours. En aucun cas est-ce que nous pouvons recevoir vos travaux par courriel. Vous devez utiliser l'outil qui est sécurisé, qui étiquette votre travail avec une date de dépôt officielle, etc. Les travaux transmis par courriel au sein du cours INF 1220 ne seront pas corrigés et recevrons une note de zéro. Il pourrait n'y avoir aucun avertissement : le dépôt du travail dans les délais est votre responsabilité. Si vous éprouvez des difficultés techniques avec l'outil de dépôt, vous devez joindre l'Université pour obtenir de l'aide. Si vous n'arrivez pas à faire fonctionner l'outil de dépôt, il est inutile de nous écrire à ce sujet, il faut joindre l'Université et son service de soutien technique. Il n'y a pas d'exception: l'utilisation de l'outil de dépôt est obligatoire dans ce cours.\nLes notes ne sont jamais transmises par courriel. Pour avoir vos résultats et la rétroaction, utilisez le portail étudiant qui vous permet un accès confidentiel à vos résultats et aux commentaires du correcteurs. Dans ce cours, les rétroactions (la correction) ne sont jamais transmises par courriel. Toutes les rétroactions sur vos travaux apparaissent au sein du portail étudiant. Le dépôt des travaux, la transmission des notes, de la rétroaction, des corrections se fait entièrement par l'entremise du portail étudiant (sans exception). Le portail est sécurisé et privé. Vous seul (et votre enseignant) avez accès à vos notes et à votre correction. Le courriel n'est pas un moyen de communication sécurisé. Quand vous nous écrivez par courriel, il n'est pas toujours aisé de vérifier votre identité. Si vous ne trouvez pas immédiatement vos notes et les commentaires de la personne qui vous a corrigé sur le portail étudiant, cherchez bien! Tout est là.\nLes solutions ne sont jamais transmises dans ce cours: si vous avez des questions sur vos résultats, vous pouvez poser des questions au professeur. Assurez-vous de poser des questions précises, et prenez le temps de consulter la rétroaction du correcteur. (Indice: si vous demandez les solutions suite à la correction de votre travail, vous nous indiquez que vous n'avez pas bien lu les consignes.)\nSi la rétroaction reçue suite à la correction de votre travail noté n'est pas claire, vous devez joindre la personne qui vous encadre pour poser des questions. Encore une fois, tenez compte du fait que les solutions ne sont jamais transmises. (Nous offrons plusieurs exercices préparatoires avec solutions.)\nLes travaux au sein de ce cours sont des travaux individuels. Il est strictement défendu de discuter du travail noté avec quiconque. En particulier, des échanges au sein de réseaux sociaux (Facebook, etc.) concernant ce travail peuvent constituer une faute académique. Vous pourriez obtenir la note de zéro ou recevoir une sanction allant jusqu'à l'exclusion du programme dans lequel vous êtes inscrit si vous avez des discussions en ligne au sujet des travaux notés de ce cours.\nIndices généraux Présentez vos solutions clairement. Plusieurs étudiants perdent des points parce que nous n'arrivons pas à les comprendre. Prenez le temps d'expliquer et d'analyser vos solutions. Selon la difficulté de la question, un ou plusieurs paragraphes peuvent être nécessaires. Soyez précis dans vos explications. Soyez factuel. Que vous produisiez du pseudo-code, un argument mathématique, ou du code Java, prenez le temps de tester votre solution. Dans le cas de pseudo-code, exécutez-le sur du papier, comme si vous étiez un robot. Si votre pseudo-code prend des paramètres, testez votre pseudo-code avec plusieurs données différentes. La plupart des étudiants qui testent leurs solutions avec rigueur obtiennent la plupart des points. Prenez votre temps et testez, testez, testez! Faites votre travail en plus d'une étape. Une fois que votre première version est terminée, ne la transmettez pas tout de suite. Revenez plus tard et relisez tranquillement votre solution. Ne transmettez votre solution qu'une fois que tout vous apparaît clair. Ne tentez pas votre chance. Si vous ne comprenez pas ce que vous faites, revenez sur la matière. Prenez le temps de poser des questions sur la matière au besoin. Faites des exercices supplémentaires. Premier problème Nous souhaitons un algorithme qui détermine si la somme des éléments d'un tableau de nombres positifs excède 100. Par ailleurs, nous souhaitons un algorithme efficace: l'algorithme doit accéder à aussi peu d'éléments du tableau que possible. Produisez un pseudo-code précis et expliquez votre solution. Vous pouvez expliquer le code sous la forme que vous souhaitez, tant que vos explications sont claires. Exécutez votre pseudo-code sur au moins 5 cas, incluant les deux cas suivants: le tableau [55,55,55,55] et le tableau [1,2,3,5,6].\nVous devez exécuter votre pseudo-code ligne-par-ligne en indiquant à chaque ligne quelle est la valeur de toutes les variables. Votre exécution doit être rigoureuse. Si l'algorithme effectue 50 opérations, votre exécution devrait comprendre 50 lignes. Vous devez produire du pseudo-code: du code informatique (par ex. Java ou Python) n'est pas accepté. Votre pseudo-code doit être précis et lisible.\nSi vous produisez un algorithme logiquement incorrect, vous pourrez obtenir la note de zéro pour cette question. Si vous omettez d'inclure un compte-rendu détaillé de l'exécution, vous pouvez obtenir la note de zéro.\nIndices concernant le premier problème Voici quelques indices concernant l\u0026rsquo;énoncé que vous pouvez prendre en compte pour vous aider. Un indice n\u0026rsquo;est jamais une question supplémentaire, un ajout à la question, ou une seconde partie. Un indice ne sert qu\u0026rsquo;à vous inspirer ou à vous aider. Vous pouvez complètement ignorer les indices. Les indices ne visent qu\u0026rsquo;à vous aider si vous le souhaitez.\nIndice 1. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Nous souhaitons un algorithme qui détermine si la somme des éléments d’un tableau de nombres positifs excède 100. Par ailleurs, nous souhaitons un algorithme efficace: l’algorithme doit accéder à aussi peu d’éléments du tableau que possible. Produisez un pseudo-code précis et expliquez votre solution. Vous pouvez expliquer le code sous la forme que vous souhaitez, tant que vos explications sont claires. Exécutez votre pseudo-code sur au moins 5 cas, incluant les deux cas suivants: le tableau [55,55,55,55] et le tableau [1,2,3,5,6]. ». Indice 2. Votre algorithme doit retourner soit vrai, soit faux. Indice 3. Votre algorithme doit fonctionner même si le tableau a une longueur de zéro. Indice 4. Votre algorithme doit fonctionner même si le tableau contient mille milliards d'éléments. Indice 5. Imaginez qu'on vous donne ce problème. On vous donne un tableau de grande taille (contenant, disons, un million d'éléments) contenant des valeurs positives et on vous demande de déterminer, le plus rapidement possible, si la somme des valeurs du tableau excède 100. Que feriez-vous? Expliquez de façon précise ce que vous feriez dans cette situation. (Il s'agit d'un indice pour vous aider à répondre à l'énoncé, pas une nouvelle question. Le tableau qu'on vous invite à imaginer n'est pas un second tableau ou un tableau supplémentaire par rapport à l'énoncé.) Indice 6. Commencez par le pseudo-code suivant qui calcule la somme des éléments d'un tableau. Entrées : Tableau de nombres positifs : tableau Variables : Nombre entier : iterateur = 0; Sorties : Nombre : somme = 0; TANT QUE iterateur \u0026lt; la longueur de tableau FAIRE somme = somme + tableau[iterateur]; iterateur = iterateur + 1; FIN TANT QUE (Vous n\u0026rsquo;êtes pas obligé de partir de ce pseudo-code. Il s\u0026rsquo;agit d\u0026rsquo;un indice, d\u0026rsquo;une suggestion. Ce bout de pseudo-code n\u0026rsquo;introduit pas une question supplémentaire. Le tableau qu\u0026rsquo;on y trouve n\u0026rsquo;est pas un second tableau en plus de celui de l\u0026rsquo;énoncé.)\nIndice 7. Ce n'est pas un problème de programmation Java, C#, C++ ou Python. Vous devez produire du pseudo-code qui est destiné à être lu et compris par un être humain. Il n'est pas nécessaire d'utiliser les constructions et types propres Java, C#, C++ ou Python. Indice 8. Beaucoup trop d'étudiants essaient de faire ce travail sans avoir fait tous les exercices sérieusement. Si vous avez analysé et compris les exercices préparatoires pour ce problème, vous ne devriez avoir aucune difficulté. Il est pratiquement impossible de ne pas arriver à faire ce problème en ayant fait tous les exercices solutionnés et en ayant bien compris toutes les solutions. Il est de votre responsabilité de faire tous les exercices. Second problème Nous souhaitons afficher les nombres entiers de 0 jusqu\u0026rsquo;à 100 à l\u0026rsquo;écran (incluant 0 mais excluant 100), en affichant \u0026ldquo;Fizz\u0026rdquo; quand le nombre est divisible par 3 et \u0026ldquo;Buzz\u0026rdquo; quand le nombre est divisible par 5.\n... 2 3 Fizz 4 5 Buzz 6 Fizz ... Un étudiant nous a offert la solution suivante. Elle est incorrecte. Pour les fins de ce travail, vous pouvez ignorer la mise en page de la sortie (polices de caractères, espaces, etc.). L\u0026rsquo;erreur de l\u0026rsquo;étudiant est logique et non pas cosmétique.\nExpliquez l\u0026rsquo;erreur et offrez une version corrigée. Exécutez votre pseudo-code corrigé, ainsi que le pseudo-code original. Expliquez les différences. Vous devez exécuter votre pseudo-code. Puisqu\u0026rsquo;il y a peut-être des dizaines d\u0026rsquo;itérations à calculer, vous pouvez résumer l\u0026rsquo;exécution sans aller dans chaque détail de chaque itération.\nVotre explication de l\u0026rsquo;erreur doit être claire et limpide. Si vous ne montrez pas que vous avez bien compris l\u0026rsquo;erreur et que vous êtes capable de l\u0026rsquo;expliquez clairement, vous pourrez recevoir une note de zéro pour cette question.\nEntrées : Valeur maximale : 100; Variables : Nombre entier : iterateur = 0; Sorties : à l\u0026#39;écran TANT QUE iterateur \u0026lt; 100 FAIRE affiche la valeur de iterateur à l\u0026#39;écran SI iterateur est divisible par 3 ALORS affiche \u0026#34; Fizz\u0026#34; à l\u0026#39;écran SINON SI iterateur est divisible par 5 ALORS affiche \u0026#34; Buzz\u0026#34; à l\u0026#39;écran FIN SI change de ligne à l\u0026#39;écran iterateur = iterateur + 1 FIN TANT QUE Indice. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Nous souhaitons afficher les nombres entiers de 0 jusqu'à 100 à l'écran (incluant 0 mais excluant 100), en affichant \"Fizz\" quand le nombre est divisible par 3 et \"Buzz\" quand le nombre est divisible par 5. Expliquez l'erreur dans ce pseudocode: TANT QUE iterateur \u003c 100 FAIRE affiche la valeur de iterateur à l'écran SI iterateur est divisible par 3 ALORS affiche \" Fizz\" à l'écran SINON SI iterateur est divisible par 5 ALORS affiche \" Buzz\" à l'écran FIN SI change de ligne à l'écran iterateur = iterateur + 1 FIN TANT QUE ».\nNotez: le cours comprend plusieurs liens vers des vidéos et autres ressources externes. Ces ressources sont toujours optionnelles.\nEn terminant Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\nIl est inutile de nous écrire pour obtenir des indices, des exemples de solutions, des pistes de départ, etc. Dans ce cours, nous n'offrons aucun indice par courriel.\nIl s'agit d'un travail noté individuel.\n"},{"id":38,"href":"/inf1901-teluq/docs/modules/module2/travail-note-2/","title":"Travail noté 2","section":"Module 2: Introduction à l'apprentissage machine","content":" "},{"id":39,"href":"/inf1901-teluq/docs/faq/","title":"FAQ","section":"Docs","content":" Question: Qu\u0026rsquo;est-ce que Java et pourquoi est-il utilisé ? # Réponse: Java est un langage de programmation orienté objet, populaire pour sa portabilité et sa robustesse. Il est utilisé pour développer des applications web, mobiles (comme Android), des logiciels d\u0026rsquo;entreprise et des jeux, car il fonctionne sur de nombreuses plateformes grâce à la machine virtuelle Java (JVM).\nQuestion: Comment installer Java sur mon ordinateur ? # Réponse: Pour installer Java, téléchargez le JDK (Java Development Kit) depuis le site officiel d\u0026rsquo;Oracle ou adoptez une version open-source comme OpenJDK. Suivez les instructions d\u0026rsquo;installation pour votre système (Windows, macOS ou Linux). Vérifiez l\u0026rsquo;installation en tapant java -version dans une invite de commande.\nQuestion: Quelle est la différence entre JDK, JRE et JVM ? # Réponse: Le JDK (Java Development Kit) inclut des outils pour développer des programmes Java. Le JRE (Java Runtime Environment) permet d\u0026rsquo;exécuter des applications Java. La JVM (Java Virtual Machine) est le moteur qui exécute le code Java compilé, inclus dans le JRE.\nQuestion: Pourquoi dois-je écrire public static void main dans mon programme ? # Réponse: La méthode public static void main(String[] args) est le point d\u0026rsquo;entrée d\u0026rsquo;un programme Java. Elle est requise pour que la JVM sache où commencer l\u0026rsquo;exécution. public la rend accessible, static permet de l\u0026rsquo;appeler sans créer d\u0026rsquo;objet, et void indique qu\u0026rsquo;elle ne retourne rien.\nQuestion: Qu\u0026rsquo;est-ce qu\u0026rsquo;une variable en Java et comment la déclarer ? # Réponse: Une variable stocke des données, comme des nombres ou du texte. Pour la déclarer, indiquez son type, son nom et, optionnellement, une valeur initiale, par exemple : int nombre = 10; pour un entier ou String texte = \u0026quot;Bonjour\u0026quot;; pour du texte.\nQuestion: Comment afficher du texte dans la console en Java ? # Réponse: Utilisez la méthode System.out.println() pour afficher du texte dans la console. Par exemple, System.out.println(\u0026quot;Bonjour le monde !\u0026quot;); affiche \u0026ldquo;Bonjour le monde !\u0026rdquo; suivi d\u0026rsquo;un saut de ligne.\nQuestion: Qu\u0026rsquo;est-ce qu\u0026rsquo;une boucle en Java et à quoi sert-elle ? # Réponse: Une boucle exécute un bloc de code plusieurs fois. Par exemple, une boucle for comme for (int i = 0; i \u0026lt; 5; i++) { System.out.println(i); } affiche les nombres de 0 à 4. Les boucles sont utiles pour répéter des tâches, comme parcourir une liste.\nQuestion: C\u0026rsquo;est quoi une classe et un objet en Java ? # Réponse: Une classe est un modèle définissant des propriétés (attributs) et des comportements (méthodes). Un objet est une instance de cette classe. Par exemple, une classe Voiture peut définir une couleur et une méthode pour conduire, et un objet maVoiture est une voiture spécifique créée à partir de cette classe.\nQuestion: Pourquoi vois-je une erreur \u0026ldquo;NullPointerException\u0026rdquo; ? # Réponse: Une NullPointerException se produit quand vous essayez d\u0026rsquo;utiliser une variable ou un objet qui n\u0026rsquo;a pas été initialisé (sa valeur est null). Vérifiez si vous avez bien créé l\u0026rsquo;objet avec new ou si la variable a une valeur avant de l\u0026rsquo;utiliser.\nQuestion: Comment lire une entrée utilisateur en Java ? # Réponse: Utilisez la classe Scanner pour lire une entrée. Par exemple :\nimport java.util.Scanner; Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;Entrez votre nom : \u0026#34;); String nom = scanner.nextLine(); Cela lit une ligne de texte entrée par l\u0026rsquo;utilisateur et la stocke dans la variable nom.\nQuestion: Pourquoi est-ce que le cours ne s\u0026rsquo;offre pas en vidéoconférence ? # Réponse: Nous nous ferons un plaisir de répondre à vos questions par courriel, mais nous n\u0026rsquo;offrons pas d\u0026rsquo;enseignement par vidéoconférence au sein du cours INF 1220. La plupart des universités québécoises ont offert des cours d\u0026rsquo;informatique en vidéoconférence (zoom, etc.) lors de la grande pandémie de 2020-2021. L\u0026rsquo;Université Laval offre plusieurs cours selon ce modèle. Ce n\u0026rsquo;est pas le modèle de l\u0026rsquo;Université TÉLUQ. La plupart de nos étudiants ne souhaitent pas se présenter à heure fixe pour une session de cours de trois heures en vidéoconférence. Il est indéniable que l\u0026rsquo;enseignement par vidéoconférence répond bien aux besoins de certains étudiants, mais il est déjà offert ailleurs et nous ne croyons pas qu\u0026rsquo;il répond aux besoins de nos étudiants.\nQuestion: J\u0026rsquo;ai remis ma solution sans explication. Ma solution était correcte, mais j\u0026rsquo;ai quand même obtenu zéro, est-ce normal ? # Réponse: Oui, vous devez expliquer vos solutions.\nQuestion: J\u0026rsquo;ai terminé l\u0026rsquo;examen et je suis déçu de ma note. Est-ce que je peux avoir une explication de mon résultat ? # Réponse: Oui, suivez les consignes fournies par l\u0026rsquo;Université. Le professeur ne va pas transmettre la correction, vous devez passer par les moyens sécurisés de l\u0026rsquo;Université.\nQuestion: Ma date de fin de cours était hier, et aujourd\u0026rsquo;hui, je n\u0026rsquo;arrive pas à déposer mon travail noté. Est-ce que je peux le transmettre par courriel ? # Réponse: Non. Si la date de fin de cours est passée, il est normal que vous ne puissiez pas déposer votre travail. Vous obtiendrez la note de zéro.\nQuestion: Il m\u0026rsquo;a fallu des heures pour compléter le module X et remettre le travail noté, est-ce normal ? # Réponse: Absolument. Il faut prévoir des dizaines d\u0026rsquo;heures par module (et donc par travail noté). Prévoyez entre 5 et 15 heures par semaine pendant 15 semaines pour compléter le cours.\nQuestion: Mon examen est dans trois mois, mais la date de fin de cours officiel est dans une semaine. Est-ce que cela signifie que j\u0026rsquo;ai trois mois supplémentaires pour remettre mes travaux ? # Réponse: Non. Tout travail remis après votre date de fin de cours peut recevoir la note de zéro.\nQuestion: Je n\u0026rsquo;ai pas reçu de lettre confirmant mon inscription au cours ? # Réponse: Dans ce cas, vous n\u0026rsquo;êtes pas reconnu comme étant inscrit au cours. Vérifiez auprès de l\u0026rsquo;Université. Vous devez avoir reçu une confirmation écrite concernant votre inscription. Bien que vous les receviez directement, les documents officiels sont aussi disponibles en cliquant sur l’onglet « Documents reçus » au sein du tableau de bord du portail étudiant.\nQuestion: J\u0026rsquo;ai besoin de plus de temps que prévu pour terminer le cours, on m\u0026rsquo;a dit que le professeur pouvait m\u0026rsquo;arranger ? # Réponse: Non. La date de fin de cours ainsi que le moment où votre dossier est fermé sont déterminés par l\u0026rsquo;Université et non pas par le professeur.\nQuestion: J\u0026rsquo;ai été très malade et j\u0026rsquo;ai pris du retard, est-ce que vous pouvez me donner plus de temps ? # Réponse: Non. La date de fin de cours ainsi que le moment où votre dossier est fermé sont déterminés par l\u0026rsquo;Université et non pas par le professeur.\nQuestion: Combien de temps faut-il investir dans ce cours ? # Réponse: Le temps nécessaire dépend de votre préparation individuelle, mais vous devriez prévoir environ 9 heures par semaine pendant quinze semaines. Les étudiants qui ont déjà de l\u0026rsquo;expérience en programmation peuvent aller beaucoup plus rapidement.\nQuestion: J\u0026rsquo;ai eu des difficultés personnelles, j\u0026rsquo;ai manqué de temps, est-ce que le professeur peut modifier ma date de fin de cours ? # Réponse: Non. Le professeur ne peut modifier votre date de fin de cours. Si vous devez reporter votre date de fin de cours, vous devez joindre l\u0026rsquo;Université.\nQuestion: J\u0026rsquo;ai du mal avec une question dans un des travaux, est-ce que je peux avoir un indice, une partie de la solution ? # Réponse: Non. Le professeur se fera un plaisir de répondre aux questions ayant trait à la matière, mais les travaux notés sont des travaux individuels. Assurez-vous de bien compléter les exercices et les lectures avant d\u0026rsquo;entreprendre les travaux notés.\nQuestion: Je dois passer l\u0026rsquo;examen le X, mais j\u0026rsquo;ai un empêchement, est-ce que vous pouvez déplacer l\u0026rsquo;examen ? # Réponse: Non. Le professeur ne gère pas le déroulement de l\u0026rsquo;examen. Vous devez joindre l\u0026rsquo;Université.\nQuestion: Je viens de passer 35 heures sur la question X du travail noté Y, est-ce que vous pouvez me donner un indice ? # Réponse: Non. Ce serait inéquitable. Nous avons un grand volume d\u0026rsquo;étudiants avec un bon taux de succès (de bonnes notes) : nous savons donc que les travaux notés ne sont pas trop difficiles. Par contre, il arrive souvent que les étudiants ne fassent pas correctement tous les exercices et toutes les lectures préparatoires, croyant à tort qu\u0026rsquo;ils gagneront du temps en allant directement au travail noté. D\u0026rsquo;autres étudiants n\u0026rsquo;ont tout simplement pas la préparation suffisante : la programmation est un langage formel qui est difficile pour ceux qui n\u0026rsquo;ont pas acquis les bases en mathématiques.\nCeci étant dit, il est parfaitement normal de passer 35 heures sur un des modules. Il faut prévoir un total d\u0026rsquo;environ 135 heures (en moyenne) pour compléter le cours. Certains étudiants peuvent aller plus rapidement. Si vous partez de plus loin et qu\u0026rsquo;il vous manque des préalables (par exemple, mathématiques), il faut prévoir un peu plus de temps.\n"},{"id":40,"href":"/inf1901-teluq/docs/math/","title":"Rappel mathématique","section":"Docs","content":" 1. Les propositions, les ensembles, les relations et les nombres. Avant de commencer, il est conseillé, pour se familariser avec certaines notations, de jeter un coup d'oeil sur le tableau des symboles et abréviations usuels. 1.1. Les propositions Une proposition mathématique est un énoncé dont on peut dire sans ambiguïté si elle est vraie ou si elle fausse. Le processus qui consiste à déterminer si une proposition mathématique est vraie ou fausse est l\u0026#x2019;objet du calcul propositionnel ou calcul des propositions et fait partie de la logique mathématique. Le résultat d\u0026#x2019;un calcul propositionnel est donc l\u0026#x2019;attribution d\u0026#x2019;une valeur de vérité à une proposition.\nAinsi, l'énoncé « Le cours INF1220 figure parmi les cours dispensés à la TELUQ au trimestre d\u0026#x2019;hiver 2021 » est une proposition mathématique et sa valeur de vérité est « vrai ». la proposition «Le cours INF1220 est mon meilleur cours » n'est pas une proposition mathématique. Dans notre contexte, quand nous parlons de proposition, nous parlons de proposition mathématique.\n1.1.1. Table des valeurs de vérités des propositions Tableau 1: Table de vérités et connecteurs logiques p q non p p ou (inclusif) q p ou (exclusif) q p et q p⇒q (p implique q) p⇔q (p équivaut à q) V V F V F V V V V F F V V F F F F V V V V F V F F F V F F F V V 1.2. Les ensembles Un ensemble est une collection d\u0026#x2019;objets. Si on appelle E cette collection, alors pour chacun de ces objets, on peut affirmer qu\u0026#x2019;il appartient à E.\nOn peut déterminer E en énumérant ses éléments, par exemple E={ o 1 , o 2 ,\u0026#x2026;} où o i est un des objets de la collection (et où on admet que pour tout objet de la collection, il y a un o i qui lui soit identique). On dit alors qu\u0026#x2019;on a défini E en extension.\nUn objet o i est appelé un élément de E. On note o i \u0026#x2208;E.\nÉtant donné un objet arbitraire, c\u0026#x2019;est-à-dire une chose quelconque, on est capable de dire si oui ou non cette chose appartient à E. si nous notons la chose en question o et qu\u0026#x2019;elle n\u0026#x2019;appartient pas à E, nous traduisons cela par o\u0026#x2209;E. Une autre façon de déterminer un ensemble est de donner une propriété qui caractérise ses éléments. Par exemple, la collection de toutes les personnes qui sont inscrites à la TELUQ pour suivre le cours INF1220 pour le trimestre d\u0026#x2019;hiver 2021 à la date du 1er mars 2021 est un ensemble. Nous pouvons le noter T. on convient dans ce cas d\u0026#x2019;écrire T={o\u0026#x2215;o est inscrit à la TELUQ pour suivre le cours INF1220 pour le trimestre d\u0026#x2019;hiver 2021 à la date du 1er mars 2021}. Le symbole / (ou |) se lit « tel que ». « être inscrit à la TELUQ pour suivre le cours INF1220 pour le trimestre d\u0026#x2019;hiver 2021 à la date du 1er mars 2021 » est la propriété caractéristique de l\u0026#x2019;ensemble T (ou des éléments de cet ensemble).\nLes nombres entiers positifs forment un ensemble ; c\u0026#x2019;est l\u0026#x2019;ensemble des entiers naturels. On le note N. N={0,1,\u0026#x2026;..}\nUn ensemble peut être fini, comme l\u0026#x2019;ensemble T. Un ensemble peut être infini, comme l\u0026#x2019;ensemble N. On admet qu\u0026#x2019;il existe un ensemble qui ne contient aucun élément. On appelle cet ensemble, ensemble vide. On le note couramment {} ou \u0026#x2205;. Un singleton est un ensemble qui a un seul élément. On admet aussi que si l\u0026#x2019;on ajoute un élément d\u0026#x2019;un ensemble E à ce même ensemble E, on ne change par l\u0026#x2019;ensemble E. On considère de ce fait, qu\u0026#x2019;un ensemble est donné par une collection distincte des objets qui le constituent, c\u0026#x2019;est-à-dire que ses éléments sont distincts. Le nombre des éléments d\u0026#x2019;un ensemble est appelé le cardinal de cet ensemble. Le cardinal de l\u0026#x2019;ensemble vide est par définition 0.\nDeux ensembles sont égaux s\u0026#x2019;ils ont exactement les mêmes éléments ou si on peut prouver qu\u0026#x2019;ils ont exactement les mêmes éléments. Par l\u0026#x2019;exemple, V={o/o est inscrit à la TELUQ pour suivre le cours INF1220 pour le trimestre d\u0026#x2019;hiver 2022 à la date du 1er mars 2021} est un ensemble vide. En effet, il n\u0026#x2019;y a aucune inscription pour le cours INF1220 à la TELUQ à cette date. Cependant, dire que cet ensemble est vide ne signifie pas qu\u0026#x2019;il n\u0026#x2019;existe pas. Il existe, mais il n\u0026#x2019;a aucun élément. V={}.\n1.2.1. Opération sur les ensembles Soient deux ensembles A et B.\nL\u0026#x2019;intersection de A et B est un ensemble formé par les éléments qui appartiennent à la fois à A et à B. On le note A\u0026#x2229;B.\nLa réunion de A et de B est un ensemble formé par les éléments qui appartiennent à A ou qui appartiennent à B. On le note A\u0026#x222a;B.\nLa différence symétrique est un ensemble formé par les éléments de A qui n\u0026#x2019;appartiennent pas à B . On le note A\u0026#x2216;B.\nLe produit cartésien de A et de B est un ensemble formé de couples (a,b) tels que a\u0026#x2208;A et b\u0026#x2208;B. On le note A×B.\n1.3. Relation binaire Une relation binaire R est un ensemble défini par la donnée de deux ensembles A et B et d\u0026#x2019;une règle qui permet d\u0026#x2019;associer certains éléments de A à certains éléments de B. R est un sous ensemble du produit cartésien A×B de A et de B. La règle associée à une relation est aussi appelée lien verbal. Le lien verbal est une proposition. On peut définir une relation en compréhension par R={(a,b)\u0026#x2208; A×B/ le lien verbal soit vérifié pour a et b}. Au lieu de noter (a,b)\u0026#x2208;R, on note simplement aRb et on lit a en relation avec b. b est l\u0026#x2019;image de a par la relation R et a est l\u0026#x2019;antécédent de b pour la relation R.\n1.3.1. Propriété d\u0026#x2019;une relation binaire Soit R une relation binaire. Lorsque les ensembles de départ et d\u0026#x2019;arrivée sont identiques, c\u0026#x2019;est-à-dire tous égaux à A, on dit simplement que R est une relation définie sur A.\nSoit A un ensemble et R une relation binaire définie sur A. R peut avoir les propriétés suivantes :\n1.3.1.1. Reflexivité Soit A un ensemble et R une relation définie sur A.\nR est réflexive si \u0026#x2200;a\u0026#x2208;A, aRa.\nExemple : la relation de divisibilité R dans N (aRb ssi a divise b) est réflexive. Question : donnez un autre exemple de relation réflexive.\nRéponse La relation d'ordre naturel R sur N définie par aRb ssi a inférieur ou égal à b est réflexive.\n1.3.1.2. Symétrie R est symétrique ssi \u0026#x2200;a\u0026#x2208;A, \u0026#x2200;b\u0026#x2208;B, aRb\u0026#x21d2;bRa.\nExemple : soit m\u0026#x2208;N* . La relation R définie sur N par aRb ssi a et b ont le même reste dans la division euclidienne par m est symétrique.\n1.3.1.3. Transitivité R est transitive ssi pour a, b, c \u0026#x2208;A, aRb et bRc \u0026#x21d2; aRc. La relation d\u0026#x2019;ordre naturel sur N est transitive. Question: Donner un autre exemple de relation transitive.\nRéponse La relation de divisibilité R dans N définie par aRb ssi a divise b est transitive.\n1.3.1.4. Antisymétrie R est antisymétrique ssi pour a, b \u0026#x2208; A, aRb et bRa \u0026#x21d2; a=b. par exemple soit E un ensemble, et P(E) l\u0026#x2019;ensemble des parties de E. La relation \u0026#x2286; sur P(E) (définie par A en relation avec B ssi A\u0026#x2286;B) est une relation antisymétrique. Question: Donnez un autre exemple de relation antisymétrique.\nRéponse La relation R de divisibilité dans N définie par aRb ssi a divise b est antisymétrique.\n1.3.2. Relation d\u0026#x2019;équivalence Soit R une relation définie sur un ensemble A. R est une relation d\u0026#x2019;équivalence si R est à la fois réflexive, symétrique et transitive. Soit m\u0026#x2208;N*. La relation R définie sur Z par aRb ssi a et b ont le même reste dans la division euclidienne par m est une relation d\u0026#x2019;équivalence.\n1.3.3. Relation d\u0026#x2019;ordre Soit R une relation définie sur un ensemble A. R est une relation d\u0026#x2019;ordre ssi elle est à la fois réflexive, transitive et antisymétrique.\nPar exemple soit E un ensemble, et P(E) l\u0026#x2019;ensemble des parties de E. La relation \u0026#x2286; sur P(E) est une relation d'ordre.\nSoit R une relation d\u0026#x2019;ordre sur A, a et b sont comparable ssi aRb ou bRa. Si \u0026#x2200; a, b \u0026#x2208;A ; a et b sont toujours comparables, on dit que R est une relation d\u0026#x2019;ordre total. S\u0026#x2019;il existe a, b tels que a et b ne sont pas comparables, R est une relation d\u0026#x2019;ordre partiel. Exemple, la relation définie sur Z par aRb si a divise b (division euclidienne) est une relation d\u0026#x2019;ordre partiel car on ne peut pas comparer 2 et 5. Question: Donner un autre exemple de relation d\u0026#x2019;ordre partiel.\nRéponse Si E est un ensemble ayant au moins deux éléments a et b, la relation \u0026#x2286; sur P(E) (définie par A en relation avec B ssi A\u0026#x2286;B) est une relation d'ordre partiel car {a} et {b} sont deux éléments de P(E) qui ne sont pas comparables par \u0026#x2286;.\nLa relation d\u0026#x2019;ordre définie sur Z par aRb si a inférieur ou égal à b est une relation d\u0026#x2019;ordre total.\nUne fonction est une relation où chaque élément de l\u0026#x2019;ensemble de départ a au plus une image dans l\u0026#x2019;ensemble d\u0026#x2019;arrivée. Dans ce cas, si A est l\u0026#x2019;ensemble de départ, B l\u0026#x2019;ensemble d\u0026#x2019;arrivée, et si on note f la relation, on appelle domaine de f (noté Dom(f) ou simplement Df) l\u0026#x2019;ensemble des éléments de A ayant une image par f. De même on appelle image de f et on note Im(f) l\u0026#x2019;ensemble des éléments de B ayant au moins un antécédent dans A.\n1.3.3.1. Ordre lexicographique Soit V un ensemble de symboles et L un ensemble défini par :\nsi v\u0026#x2208;V, alors v\u0026#x2208;L;\nsi l\u0026#x2208;L et e\u0026#x2208;L alors el et le appartiennent à L. V est appelé vocabulaire et L est l\u0026#x2019;ensemble des mots construits sur ce vocabulaire. Un mot l de L s\u0026#x2019;écrit v n ,\u0026#x2026;, v 0 , où v i \u0026#x2208;V. On peut remarquer que si V est l\u0026#x2019;ensemble des 26 lettre de l\u0026#x2019;alphabet française, alors L est l\u0026#x2019;ensemble des mots possibles de la langue française (si on assimile toutes les voyelles accentuées à leur équivalent non accentué, c\u0026#x2019;est-à-dire qu\u0026#x2019;on laisse tomber les accents) ; en fait L contient tous les mots de la langue française, mais aussi des choses comme rrrrrrrrr sont des mots de\u0026nbsp;L.\nQuestion: Que vaut L si V est l\u0026#x2019;ensemble des chiffres de 0 à 9 ?\nRéponse Voir plus bas.\nOn suppose que V est muni d\u0026#x2019;une relation d\u0026#x2019;ordre total notée \u0026#x2264; (avec l'ordre strict noté \u0026lt;). Soit a et b deux éléments de L tels que a= a m ,\u0026#x2026;, a 0 et b= b n ,\u0026#x2026;, b 0 . \u0026#x2200;i\u0026#x2208;N, a i , b i \u0026#x2208;V. On pose p=min(m,n) le plus petit des deux entiers m et n. On définit sur L la relation R par aRb ssi ( a m \u0026lt; b n ) ou ( a m = b n et a m \u0026#x2212; 1 \u0026lt; b n \u0026#x2212; 1 ) ou ( a m = b n et a m \u0026#x2212; 1 = b n \u0026#x2212; 1 et a m \u0026#x2212; 2 \u0026lt; b n \u0026#x2212; 2 ) ou \u0026#x2026;ou ( a m = b n et a m \u0026#x2212; 1 = b n \u0026#x2212; 1 et \u0026#x2026;et a m \u0026#x2212; p + 1 = b n \u0026#x2212; p + 1 et a m \u0026#x2212;p \u0026lt; b n \u0026#x2212; p ) ou ( a m = b n et a m \u0026#x2212; 1 = b n \u0026#x2212; 1 et \u0026#x2026; et a 0 = b n \u0026#x2212; m si m \u0026#x2264; n).\nR est une relation d\u0026#x2019;ordre totale sur L. R qui est aussi notée \u0026#x2264; et prolonge la relation \u0026#x2264; de V est appelée l\u0026#x2019;ordre lexicographique sur L.\nSi V est l'ensemble des chiffres de 0 à 9, l'ensemble L contient l'ensemble des entiers naturels N. Il faut remarquer que sur cet ensemble L ordonné par \u0026#x2264;, 0 est différent par exemple de 00, ce qui n'est pas le cas dans l'ensemble N muni de la relation d'ordre \"naturelle\" (la relation inférieure ou égale). 1.4. L\u0026#x2019;ensemble des entiers naturels N et les autres ensembles de nombre. Il faut noter que les entiers naturels forment un ensemble particuliers. Pour illustrer le lien étroit qu\u0026#x2019;il y a entre la théorie des ensembles et les entiers naturels, il faut savoir qu\u0026#x2019;on peut construire l'ensemble des entiers naturels en procédant comme suit : 0=\u0026#x2205;, 1=successeur de 0, c'est à dire 1={0}, 2=successeur de 1, c'est à dire 2={0,1}, etc.\nCommençons par voir de façon générale les lois de composition sur un ensemble.\n1.4.1. Lois de composition dans un ensemble Soit E et G deux ensembles. Une loi de composition T dans l\u0026#x2019;ensemble E est une fonction de E×E vers G qui à tout couple ( a, b) d'éléments de E associe un unique élément c de G tel que c=aTb.\nSoit E un ensemble muni d'une loi T.\n1.4.1.1. Ensemble stable par une loi Si \u0026#x2200;a,b\u0026#x2208;E, a T b \u0026#x2208; E, alors la loi T est interne sur E. On dit aussi que E est stable par la loi T. On note (E,T) pour signifier que E est muni de la loi interne T.\nPar exemple l\u0026#x2019;addition est interne à l\u0026#x2019;ensemble des entiers naturels N.\n1.4.1.2. Élément neutre pour une loi Un élément e de E est un élément neutre pour T ssi pour tout élément a de E , aTe=eTa=a\nExemples\u0026nbsp;: 0 est l'élément neutre pour l'addition + sur l'ensemble N des entiers naturels : Pour tout entier naturel n, on a n+0=0+n=n.\nIl en est de même pour 1 qui est l'élément neutre pour la multiplication × sur l'ensemble N des entiers naturels : Pour tout entier naturel n, on a n×1=1×n=n.\nQuestion: Existe t-il un élément neutre pour la division ÷ sur l'ensemble N des entiers naturels?\nRéponse Non car malgré que pour tout n élément de N on ait n÷1=n, on n'a 1÷n=n que si n vaut 1.\nSoit (E,T) un ensemble E muni d\u0026#x2019;une loin interne T.\nOn a les propriétés suivantes :\n1.4.1.3. Associacitivité La loi T est associative si pour tous éléments a , b et c de E, (a T b) \u0026#x22a4; c = a \u0026#x22a4;( b\u0026#x22a4; c)=a \u0026#x22a4;b\u0026#x22a4; c\nExemple\u0026nbsp;: l'addition + est associative sur N.\n1.4.1.4. Commutativité La loi \u0026#x22a4; est commutative si pour tous éléments a et b de E, a \u0026#x22a4; b = b \u0026#x22a4; a.\nExemple\u0026nbsp;: l'addition + est commutative sur N.\n1.4.1.5. Symétrie Deux éléments a et b sont symétriques pour \u0026#x22a4; si a \u0026#x22a4; b = b \u0026#x22a4; a = e ( e étant l'élément neutre de E pour la loi \u0026#x22a4;). Si tout élément de e admet un symétrique pour la loi \u0026#x22a4;, on dit que la loi \u0026#x22a4; est symétrisable.\n1.4.1.6. Distributivité \u0026#x22a4; est distributive à gauche par rapport à une autre loi\u0026#x22a5; si pour tous éléments a, b, c de E, a \u0026#x22a4; (b \u0026#x22a5; c) = (a \u0026#x22a4; b )\u0026#x22a5;( a\u0026#x22a4; c)\n\u0026#x22a4; est distributive à droite par rapport à une autre loi \u0026#x22a5; si pour tous élément a, b, c de E, (b \u0026#x22a5; c) \u0026#x22a4;a = (b \u0026#x22a4;a) \u0026#x22a5;( c\u0026#x22a4; a)\n\u0026#x22a4; distributive pour \u0026#x22a5; si et seulement si elle est distributive à gauche et à droite par rapport à \u0026#x22a5;.\nLa multiplication × dans N est distributive par rapport à l'addition + dans N.\nDans la suite, on appellera opération les lois de composition dans l\u0026#x2019;ensemble N des entiers naturels. On note N* l\u0026#x2019;ensemble N privée du singleton {0}. N*=N\u0026#x2216;{0}\nL\u0026#x2019;addition + et la multiplication × usuelles sont des opérations internes sur N. c\u0026#x2019;est-à-dire que N est stable par chacune de ces opérations.\nLa soustraction \u0026#x2212; et la division ÷ usuelles ne sont pas des opérations internes dans N. C\u0026#x2019;est le besoin d\u0026#x2019;avoir des ensembles stables pour ces opérations qui ont guidé le développement de nouveaux ensembles de nombres. Ainsi, l\u0026#x2019;ensemble des entiers rationnels (termes que nous privilégions à entiers relatifs) Z est construit par symétrisation de N; c\u0026#x2019;est-à-dire que Z est construit de telle sorte que le symétrique par + d\u0026#x2019;un entier naturel n soit dans Z. Q l\u0026#x2019;ensemble des nombres rationnels est construit sur la base d\u0026#x2019;une relation d\u0026#x2019;équivalence définie sur Z par (a,b)R(c,d) ssi a×d=b×c ; on note a\u0026#x2044;b=c\u0026#x2044;d. De façon générale, si x et y sont deux entiers rationnels, x\u0026#x2044;y défini un nombre rationnel si y\u0026#x2260;0; x est le numérateur et y est le dénominateur.\nSoit x\u0026#x2044;y un nombre rationnel. Si x/y peut s\u0026#x2019;écrire sous la forme a\u0026#x2044;b où a est un entier rationnel et b une puissance de 10 (\u0026#x2203;k\u0026#x2208;N tel que b= 10 k ), alors x/y est un nombre décimal. On note D l'ensemble des nombres décimaux.\nDisposant de Q, on peut construire l\u0026#x2019;ensemble des nombres réels en utilisant les coupures de Q, notion due à Cantor et Dedeking. Par exemple soit C1=Q-\u0026#x222a;{a\u0026#x2208;Q+*. a 2 \u0026lt;2} et C2={a\u0026#x2208;Q+*. a 2 \u0026gt;2}. C1 et C2 sont deux coupures de Q qui définissent le nombre 2 . 2 \u0026#x2209;Q et 2 \u0026#x2208;R. On peut, avec cette méthode de coupure, définir n'importe quel nombre réel. On pose souvent I=R\u0026#x2216;Q. On a les inclusions suivante : N\u0026#x2282;Z\u0026#x2282;D\u0026#x2282;Q\u0026#x2282;R.\nSoit a\u0026#x2208;Z et b\u0026#x2208;Z*. Il existe un unique couple d\u0026#x2019;entier rationnels (q, r)\u0026#x2208;ZxN tel que a=b×q+r avec 0\u0026#x2264;r\u0026lt;|b|. On dit dans ces conditions que q est le quotient et r est le reste de la division euclidienne de a par b; a est le dividende et b est le diviseur. On peut restreindre cette définition à N en remplaçant Z par N. On parle alors de division euclidienne dans N. On dit que b divise a ou que b est un diviseur de a lorsque r vaut 0.\n1.4.1.6.1. Nombre pair / impair. Soit n\u0026#x2208;Z. n est un nombre pair ssi n est divisible par 2. 0 est un nombre pair. Un nombre qui n'est pas pair est impair. On note parfois 2Z (respectivement 2Z+1) l'ensemble des nombres entiers rationnels pairs (respectivement impairs).\nRemarques : si on remplace dans cette définition Z par N, alors on obtient qu\u0026#x2019;un entier naturel n\u0026#x2208;N est pair ssi n est divisible par 2. Les entiers naturels pairs sont ceux dont le chiffre des unités est pair. Les entiers naturels impairs sont ceux dont le chiffre des unités est impair.\n1.4.1.6.2. Nombre premier. Soit n\u0026#x2208;Z. n est un nombre premier ssi n a exactement quatre diviseurs : -1,1, -n et n. 0 et 1 ne sont pas des nombres premiers. 2 est un nombre premier.\nRemarque : si on remplace dans cette définition Z par N, alors on obtient qu\u0026#x2019;un entier naturel n\u0026#x2208;N est premier ssi n a exactement deux diviseurs : 1 et n.\n1.4.1.6.3. Grammaire du nombre. Soit VN={0,1,2,3,4,5,6,7,8,9}. On peut générer les entiers naturels selon la règle suivante :\nTout élément de VN est un nombre entier naturel.\nSi a et b sont des nombres entiers naturels, alors ab est un nombre entier naturel si a\u0026#x2260;0.\nLes éléments de VN sont aussi appelés les chiffres.\nVZ=VN\u0026#x222a;{-,+}\nTout entier naturel est un entier rationnel.\nSi a est un entier naturel, \u0026#x2212;a et +a sont des entiers rationnels\nVQ=VZ\u0026#x222a;{\u0026#x2044; ,,}\nTout entier rationnel est un nombre rationnel.\nSi a et b sont des entiers rationnels a,b est un nombre rationnel ; de plus si b\u0026#x2260;0, a b est un nombre rationnel.\nSi a et b sont des nombres rationnels, a b est aussi un nombre rationnel si b\u0026#x2260;0.\nLes opérations + et × sont associatives et commutatives. Les opérations × et ÷ sont distributives par rapport aux opérations \u0026#x2013; et +.\nLors de la simplification des expressions algébriques, il faut aller de la gauche vers la droite, et en calculant d\u0026#x2019;abord toutes les expressions entre parenthèse () ou tout autre signe qui tient lieu de parenthèses (ça peut être des crochets [ ] ou plus rarement des accolades {}). Les parenthèses ont donc toujours la plus grande priorité. Le tableau ci-dessous donne les régles de priorité.\nRègles de priorité Opérations Abréviations 1. L’intérieur des parenthèses doit être calculé. Lorsqu’il y a parenthèses, crochets et accolades, il faut simplifier prioritairement l’opération en débutant par les parenthèses intérieures : solutionner de l’intérieur vers l’extérieur. Parenthèses (ou assimilées) P 2. Les nombres affectés d’exposants doivent être évalués. Exponentiation E 3. Les divisions et les multiplications doivent être calculées. Ces deux opérations ont la même priorité. Elles sont évaluées dans l’ordre où elles apparaissent dans l’expression numérique établie, en se référant à la convention d’écriture indiquée plus loin. Divisions\nMultiplications D\nM 4. Finalement, les additions et les soustractions doivent être calculées. Ces deux opérations ont la même priorité. Elles sont évaluées à partir de la gauche de l’expression numérique en allant vers la droite (convention d’écriture). Additions\nSoustractions A\nS On peut se rappeler cet ordre de priorité avec l'acronyme mnémonique PEDMAS.\nDans l'ensemble R des nombres réels, deux éléments de R symétriques pour l'addition sont plus communément appelés opposés . Pour la multiplication on parle d'inverses.\n\u0026#x2003;\n2. Notion de variables et fonctions élémentaires sur les nombres 2.1. La notion de variable Soit E et F deux ensembles, f une fonction de E vers F. En général, f est donnée par une expression qui permet de déterminer l\u0026#x2019;image d\u0026#x2019;un élément e quelconque de E. Cela se fait en remplaçant dans l\u0026#x2019;expression de f certains symbole par l\u0026#x2019;élément e en question. Supposons par exemple E=F =R et f la fonction qui a un nombre réel associe son produit par une constante a et ajoute à ce produit une constante b. On a par exemple f(2)=a×2+b. Ce qui change dans le calcul de l\u0026#x2019;image d\u0026#x2019;un élément quelconque, ce ne sont pas les constantes a et b qui sont fixées une fois pour toute pour la fonction f, mais la valeur de l\u0026#x2019;élément. Il est commode de représenter cet état de chose par un symbole auquel on substitue l\u0026#x2019;élément quand celui-ci devient connu. Ce symbole est donc la variable associée à la fonction. Dans le cas de la fonction f ci-dessus, on écrira f(t) = a×t + b. Et t est la variable dans cette expression. Cette variable représente les éléments de l\u0026#x2019;ensemble de départ. C\u0026#x2019;est elle qui varie quand on passe d\u0026#x2019;un élément à un autre, on dit qu\u0026#x2019;elle parcourt l\u0026#x2019;ensemble de départ, ou plus exactement le domaine de définition de la fonction. Il est a noter que ce formalisme permet de décrire f et de connaître ses propriétés mathématiques sans avoir besoin de calculer l\u0026#x2019;image de chaque élément de\u0026nbsp;E.\nCette notion de variable en mathématique est assez proche de la notion de variable en informatique, tout comme l\u0026#x2019;est aussi la notion de fonction. Ainsi, on peut remarquer que donner une valeur à une variable (en mathématique) est similaire à affecter une valeur à une variable (en informatique).\nIl convient aussi de bien remarquer que, même sans explicitement donner des valeurs à a et b dans la fonction f ci-dessus, nous savons que ces symboles représentent des constantes. Mais pour calculer la valeur (réelle) de l\u0026#x2019;image par f d\u0026#x2019;un nombre réel, nous avons nécessairement besoin, à ce moment-là, de connaître les valeurs de ces symboles qui sont constantes et ne changeront donc plus une fois fixées. Là encore on peut remarquer que cette notion de constante en mathématique est assez proche de la notion de constante en informatique.\n2.2. Fonctions numériques élémentaires usuelles. Tableau 3: Fonctions numériques élémentaires usuelles\nNom Expression Principales propriétés Exemples Fonction puissance fa(x)=xa Partout où fa et fb ont à la fois un sens et sont à la fois définies, on a fa+b=fa×fb.\nSi a∈N, fa est définie sur R.\nSi a∈Z, et a\u0026lt;0, fa est définie sur R*.\nSi a∈Q, il faut distinguer deux cas :\n- Si a=p/q avec q pair, alors fa est définie sur R+ si a≥0 et sur R*+ si a\u0026lt;0 - Si a=p/q avec q impair, alors fa est définie sur R si a≥0 et sur R* si a\u0026lt;0.\nPour tout autre cas fa n’a de sens que si a≥0 et n’est définie que sur R*+ ; on a alors f(x)=ealnx. f(x)=x-2/3\nf(x)=x4\nf(x)=x1/3\nf(x)=x1/2. Fonction exponentielle f(x)=ex f(x)×f(y)=f(x+y). f est définie sur R. Fonction exponentielle de base a fa(x)=ax fa n’a de sens que si a\u0026gt;0. On a alors fa(x)×fa(y)=fa(x+y) et fa est définie sur R. f(x)=4x Fonction logarithme f(x)=ln(x) f(x×y)=f(x)+f(y). f est définie sur R*+. Fonction logarithme de base a fa(x)=-ln(a)ln(x) fa a un sens ssi a\u0026gt;1. Si a=10, fa est le logarithme décimal, et noté simplement log. fa est définie sur R*+ là où elle a un sens (a\u0026gt;1). On a fa(x×y)=fa(x)+fa(y). 2.3. Suites et séries numériques réelles Une suite numérique réelle est une application u : N\u0026#x2192;R, n\u0026#x21a6;u(n). On note souvent u(n), l'image par n de u, plus simplement u n . La suite u est souvent notée ( u n ) n \u0026#x2208;N.\nLe terme u n s'apelle le terme général de la suite. Il arrive quelquefois qu'une suite soit définie seulement sur une partie de N. Dans ce cas, on considère qu'elle est définie partout sur N et qu'elle est nulle pour les termes pour lesquels elle n'est pas explicitement définie. Par exemple, si on considère la suite u définie par u n =1/n pour n\u0026gt;0 sans d'autres précisions, on peut toujours supposer que u 0 =0. Une suite n'est interessante que s'il y a une façon de déterminer, pour un entier n quelconque, le terme u n de la suite; on parle alors de suite logique. Une suite logique peut être donnée par une expression de u n en fonction de n; u n =f(n) ou f est une fonction avec Df=N. Une suite logique peut être donnée par une relation entre les termes de la suite. Par exemple u n peut être une fonction de u n \u0026#x2212; 1 ; u n =f( u n \u0026#x2212; 1 ) où f est une fonction et il y a au moins un terme de la suite connu (il existe n0 tel que u no soit connu); dans ce cas on parle de suite recurrente. Un exemple de suite est (suite de Fibonacci) u 0 =0 , u 1 =1 et u n = u n \u0026#x2212; 1 + u n \u0026#x2212; 2 pour n\u0026#x2265;2.\nSoit ( u n ) n \u0026#x2208;N une suite.\nOn apelle série numérique réelle de terme général u n , que l'on note \u0026#x3a3; u n , la suite des sommes partielles ( S n ) n \u0026#x2208;N , où pour tout n\u0026#x2208;N, S n = \u0026#x3a3; k = 0 n u k .\nPar exemple la série de terme général u n =1/n si n\u0026#x2265;1 est définie par S n = \u0026#x3a3; k = 1 n 1 \u0026#x2044; k .\n2.4. Matrices réelles Soient I et J deux ensembles. On appelle matrice à coefficients réels ou encore matrice réelle toute application f : I×J \u0026#x2192; R. Si l\u0026#x2019;on confond f à son image, alors on peut légitimement représenter une matrice f de type I×J par une famille ( f ( i , j ) ) ( i , j ) \u0026#x2208; I × J . On pose plus simplement f(i,j) = f ij et les f ij sont appelés coefficients de la matrice. Un cas particulier important, lorsque I={1,2,\u0026#x2026;m} et J={1,2,\u0026#x2026;n} on dit que f est une matrice de type (m, n). Il est alors commode de représenter f par un tableau rectangulaire du type f= ( a 11 a 12 . . . a 1 n a 21 a 22 . . . a 2 n a m 1 a m 2 a mn ) où f ij = a ij .\nLorsque m=n, la matrice f est dite carrée. Les termes a 11 , a 22 ,\u0026#x2026;, a nn sont appelés les termes diagonaux.\nUne matrice carrée est dite triangulaire supérieure (respectivement inférieure) si les termes situés en dessous (respectivement au-dessus) de la diagonale sont tous nuls.\nOn a respectivement A =( a ij ) avec 1\u0026#x2264;i\u0026#x2264;n, 1\u0026#x2264;j\u0026#x2264;n et a ij =0 si i\u0026gt;j (respectivement i\u0026lt;j). Exemples\u0026nbsp;: A= ( 1 2 0 0 0 2 0 0 0 0 0 0 0 0 0 0 ) , B= ( 1 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 ) , alors A est triangulaire supérieure et B est triangulaire inférieure.\nUne matrice carrée est diagonale si elle est à la fois triangulaire supérieure et triangulaire inférieure. A=( a ij ) avec 1\u0026#x2264;i\u0026#x2264;n, 1\u0026#x2264;j\u0026#x2264;n et a ij =0 si i\u0026#x2260;j.\nDans la suite, on désigne par Mm,n( R ) l\u0026#x2019;ensemble des matrices à m lignes et n colonnes à coefficients réels.\n2.4.1. Adition de deux matrices Soit A=( a ij ) avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;n et B=( b ij ) avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;n deux éléments de Mm,n( R ). On définit la somme C de A et de B par :\nC=A+B et C=( c ij ) avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;n tels que c ij = a ij + b ij . C\u0026#x2208;Mm,n( R ).\n2.4.2. Produit de deux matrices Soient A\u0026#x2208;Mm,n( R ) avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;n et B\u0026#x2208;Mn,p( R ) avec 1\u0026#x2264;i\u0026#x2264;n, 1\u0026#x2264;j\u0026#x2264;p.\nLe produit C=( c ij )avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;p de A et de B est la matrice définie par c ij = \u0026#x3a3; k = 1 n a ik b kj Exemple\u0026nbsp;:A= ( 1 2 3 ) et B= ( 1 2 3 ) , A×B=14 et B×A= ( 1 2 3 2 4 6 3 6 9 ) 2.4.3. Transposition Soit A\u0026#x2208;Mm,n( R ). A=( a ij ) avec 1\u0026#x2264;i\u0026#x2264;m, 1\u0026#x2264;j\u0026#x2264;n. On appelle transposée de A la matrice A \u0026#x22a5; \u0026#x2208;Mn,m( R ) définie par A \u0026#x22a5; =( b ij ) où b ij = a ji .\nExemple\u0026nbsp;:: A= ( 1 2 3 ) et B= ( 1 2 3 ) , alors A \u0026#x22a5; =B et B \u0026#x22a5; =A.\nRemarque: La transposée de la transposée d'une matrice est égale à cette matrice.\n3. Variable aléatoire et fonction de variable aléatoire 3.1. Variable aléatoire Toute mesure d\u0026#x2019;une grandeur X dans un univers \u0026#x3a9; dont les valeurs dépendent du hasard est dite variable aléatoire. On distingue en générale deux types de variable aléatoire. Le type discret et le type continu.\n3.1.1. Variable aléatoire discrète. Une variable aléatoire X est dite discrète lorsque son ensemble de définition, c\u0026#x2019;est-à-dire l\u0026#x2019;ensemble de ses valeurs possibles noté X(\u0026#x3a9;) est un ensemble fini. Un élement de X(\u0026#x3a9;) est appelé un évènement élémentaire. Pour une variable aléatoire discrète X, on définit les notions suivantes :\n3.1.1.1. Loi de probabilité. On appelle loi de probabilité ou encore loi de distribution de la variable aléatoire X la fonction définie par p : X(\u0026#x3a9;)\u0026#x2192;[0, 1], x i \u0026#x21a6;p(X= x i )= p i où x i \u0026#x2208;X(\u0026#x3a9;). On rappelle que\n\u0026#x2200;i, p i \u0026#x2265;0; \u0026#x3a3; p i x i \u0026#x2208; X ( \u0026#x3a9; ) =1 Exemple\u0026nbsp;: Une plante peut avoir de 0 à 4 fleurs avec les probabilités suivantes :\nTableau 4: Exemple de distribution de probabilité Nombre de fleurs xi 0 1 2 3 4 Probabilité pi 2k 1/8 1/8 3/8 k Question: Calculer k pour que ce tableau corresponde à une distribution de probabilité.\nRéponse k=1/8 car la somme des probabilités doit donner 1.\n3.1.1.2. Fonction de répartition On appelle fonction de répartition ou fonction cumulative de la variable aléatoire X la fonction F définie par F : X(\u0026#x3a9;)\u0026#x2192;[0,1], x i \u0026#x21a6;F( x i )=p(X\u0026lt; x i )= \u0026#x3a3; p ( X = x j ) x j \u0026lt; x i .\nRemarque : Certains ouvrages définissent F par F( x i )=p(X \u0026#x2264; x i ).\nParmi les lois de probabilités discrètes, on peut citer :La loi uniforme sur [1,n]. elle est données par p(X=x)=1/n avec x\u0026#x2208;{1,\u0026#x2026;,n}, la loi de Bernoulli de paramètre p. elle est donnée par p(X=x)= p x q 1 \u0026#x2212; x avec p+q=1 et x\u0026#x2208;{0,1}. Elle correspond au schéma succès/échec avec une probabilité de succès p.\nÉtant données deux variables aléatoires X et Y on peut définir une variable aléatoire Z=(X,Y). Z est appelé variable aléatoire à deux dimensions ou couple de variables aléatoires.\nÉtant donnée une variable aléatoire X et une fonction g quelconque, on peut définir une autre variable aléatoire Y par Y=g(X). La détermination de la loi de Y se fait alors en prenant en considération la loi de X et le comportement de la fonction g.\nOn peut utiliser une loi de probabilité connue pour, par exemple, générer des nombres aléatoires. Toutefois, il convient de noter qu'en raison du caractère déterministe des algorithmes informatiques, les nombres générés par les programmes informatiques sont pseudo-aléatoires.\n4. Annexe Tableau 5: Quelques abréviations et symboles usuels, ainsi que leur signification Symbole Description Exemple ssi Si et seulement si. Placé après une expression propositionnelle, exprime une condition nécessaire et suffisante pour que cette expression propositionnelle soit vraie. Un nombre entier est pair ssi son dernier chiffre est pair. Σi=pn Sommation de n-p+1 termes indexés par i, et i variant de p à n. Σi=1ni désigne la somme des n premiers entiers naturels. Il convient alors de remarquer que le résultat de cette somme est identique à Σi=0ni mais la sommation est différente puisque les deux sommations ont un nombre de termes différents. On peut avoir une double, une triple,\u0026hellip; sommation avec deux, trois\u0026hellip; indices ij, ijk,\u0026hellip; chacun des indices variant à son tour. ≤ Placé entre des termes, ce symbole signifie que le membre de gauche est plus petit ou égal au membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite ou lui est égal (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels N, 1≤2 et 2≤2. Pour la relation de divisibilité dans N, c\u0026rsquo;est-à-dire a en relation avec b ssi a divise b ; 2≤4 et 2≤2, mais on ne peut pas comparer 2 et 5. ≥ Placé entre des termes, ce symbole signifie que le membre de gauche est plus grand ou égal au membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite ou lui est égal (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels N, 2≥1 et 2≥2. Pour la relation de divisibilité dans N, c\u0026rsquo;est-à-dire a en relation avec b ssi a divise b ; 4≥2 et 2≥2, mais on ne peut pas comparer 5 et 2. \u0026lt; Placé entre des termes, ce symbole signifie que le membre de gauche est strictement plus petit que le membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite et lui est différent (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels N, 1\u0026lt;2. Pour la relation de divisibilité dans N, c\u0026rsquo;est-à-dire a en relation avec b ssi a divise b ; 2\u0026lt;4, mais on ne peut pas comparer 2 et 5. \u0026gt; Placé entre des termes, ce symbole signifie que le membre de gauche est strictement plus grand que le membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite et lui est différent (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels N, 2\u0026gt;1. Pour la relation de divisibilité dans N, c\u0026rsquo;est-à-dire a en relation avec b ssi a divise b ; 4\u0026gt;2, mais on ne peut pas comparer 5 et 2. ∀ Quantificateur universel. ∀ a se lit pour tout a\u0026hellip; ∀ a∈N, a≥0 pour tout élément a de l\u0026rsquo;ensemble N, a est supérieur ou égal à 0. ∃ Quantificateur existentiel. ∃ a se lit il existe au moins un a\u0026hellip; ∃ a∈N tel que a≠0, il existe au moins un élément a de l\u0026rsquo;ensemble N qui est différent de 0. ∈ C\u0026rsquo;est le symbole d\u0026rsquo;appartenance. a∈A signifie que a est un élément de l\u0026rsquo;ensemble A. Utilisé après un quantificateur, et une suite de symboles, il signifie que ces symboles sont éléments de l\u0026rsquo;ensemble qui suit. Par exemple : ∀ a,b,c ∈N signifie pour tous éléments a, b et c de N. ∉ C\u0026rsquo;est le symbole de non-appartenance. a∉A signifie que a n\u0026rsquo;est pas un élément de l\u0026rsquo;ensemble A. −1∉N. ⊆ Placé entre deux ensembles, signifie que l\u0026rsquo;ensemble de gauche est inclus dans l\u0026rsquo;ensemble de droite ou lui est égal. Si A et B sont deux ensembles, A⊆A∪B. ⊂ Placé entre deux ensembles, signifie que l\u0026rsquo;ensemble de gauche est strictement inclus dans l\u0026rsquo;ensemble de droite (et donc en est différent). N⊂Z. ⇒ Implication logique. Placé entre deux propositions, ce symbole indique que la proposition de gauche implique celle de droite. p⇒q est faux ssi p est vrai et q faux. | | Valeur absolue. Si a est placé entre les deux barres, le résultat est le nombre positif a si a est positif et -a si a est négatif. |a|=a si a≥0 et |a|=−a si a≤0. |-2|=|2|=2. "},{"id":41,"href":"/inf1901-teluq/docs/ia/","title":"Intelligence artificielle","section":"Docs","content":" Dans ce cours, l'utilisation de l'intelligence artificielle (Claude, ChatGPT, Copilot, Grok, etc.) est permise (mais optionnelle). Cependant, vous devez l'utiliser de manière responsable\u0026nbsp;:\nDécrivez votre utilisation de l'IA. Une utilisation de l'IA sans déclaration peut être considérée comme une forme de faute. Contrairement à ce que vous pourriez croire, déclarer votre utilisation de l'IA vous protège. Expliquez votre démarche. Qu'est-ce que vous avez fait avec l'IA\u0026nbsp;? Nous vous encourageons à inclure des copies des résultats de vos interactions avec l'IA. Assurez-vous de bien expliquer vos résultats, en vos propres mots. "},{"id":42,"href":"/inf1901-teluq/docs/courriel/","title":"Petit guide d’usage du courriel efficace","section":"Docs","content":"Lors de l\u0026rsquo;écriture d\u0026rsquo;un courriel, être bref est important. Omettez les formules de salutation, les signatures surfaites, etc.\nAttention aux émotions : Il est facile quand on reçoit ou transmet un courriel de s\u0026rsquo;emporter ou de lire dans les messages reçus des sentiments. Dans un contexte professionnel, évitez d\u0026rsquo;écrire un courriel alors que vous êtes énervé.\nChoisissez les destinataires de votre courriel avec soin. Il est pratiquement toujours mal avisé de transmettre un courriel à un grand groupe, à moins que le courriel soit une communication formelle. Dans le doute, écrivez un courriel à un seul destinataire.\nAvant de répondre à un courriel, prenez le temps de bien le lire. Si on vous demande de fournir des informations ou détails additionnels, prenez le temps de le faire, ou expliquez clairement pourquoi cela n\u0026rsquo;est pas possible ou souhaitable.\nL\u0026rsquo;objet d\u0026rsquo;un courriel doit en refléter le contenu. Il faut éviter les objets génériques (par ex., « une question »). Il faut éviter à tout prix les objets qui ne réflètent pas le contenu (par ex. intitulé un cours « travail 2 » alors que celui-ci porte en fait sur l\u0026rsquo;examen. Si vous utilisez un objet de courriel vague ou absent, il faut vous attendre à ce que votre courriel puisse ne pas être traité correctement.\nSi vous avez plusieurs sujets distincts, il est souvent préférable d\u0026rsquo;écrire plusieurs courriels distincts, chacun ayant un objet distinct.\nDans un contexte professionnel, il est nettement préférable d\u0026rsquo;envoyer un courriel identifié à votre nom. Il n\u0026rsquo;est pas pratique d\u0026rsquo;envoyer des courriels vous identifiant sous le nom de votre conjoint, par exemple. Il peut être amusant de se donner des pseudonymes (« la chouette », « le montréalais ») entre amis, mais ce n\u0026rsquo;est pas souhaitable dans un contexte professionnel.\nUn courriel destiné à un humain doit obligatoirement avoir un corps de texte. Un courriel doit être clair et fournir tous les détails nécessaires. Par exemple, si vous écrivez à quelqu\u0026rsquo;un pour lui faire part d\u0026rsquo;un problème ou d\u0026rsquo;une incompréhension, il faut fournir tous les détails, incluant les démarches que vous avez déjà entreprises. On peut être précis sans nécessairement utiliser beaucoup de mots. Préparer un courriel précis peut exiger plus d\u0026rsquo;effort et de temps, mais c\u0026rsquo;est un signe de respect envers le récipiendaire.\nSi vous écrivez un courriel pour faire rapport de problèmes techniques, soyez aussi précis que possible. Joignez des saisies d\u0026rsquo;écran au besoin.\nLorsque possible, on évite les pièces jointes. Lorsque celles-ci sont nécessaires, on s\u0026rsquo;assure que le récipiendaire pourra aisément en prendre connaissance. ll faut donc éviter les formats de fichier qui ne correspondent pas à un usage courant. Les formats propriétaires qui ne sont pas courants et qui nécessitent l\u0026rsquo;installation de logiciel particulier sont à éviter.\nLes fichiers de bureautique (par ex., Word, PDF) sont déjà compressés. Transmettre les fichiers en question dans une archive compressée ajoute des manipulations inutiles.\nÀ moins de transmettre des fichiers très volumineux, la compression des fichiers attachés est inutile étant donné la généreuse bande passante dont nous bénéficions. Si on doit utiliser un format d\u0026rsquo;archive compressé, il faut utiliser un format qui est largement supporté par les divers systèmes d\u0026rsquo;exploitation (comme le format zip basique).\nCertains logiciels de courriel (Outlook) ne permettent pas la transmission de fichiers avec certaines extensions. Dans de tels cas, il est acceptable de renommer l\u0026rsquo;extension du fichier et d\u0026rsquo;inclure dans le corps du message une explication. Par exemple, tous les fichiers au format texte (.xml, .html), peuvent être transmis avec l\u0026rsquo;extension « .txt ».\nLes courriels automatisés non sollicités sont du pourriel. Ainsi, il ne faut pas transmettre des réponses automatisées (par ex., des accusés de réception) à des destinateurs non avisés.\nLes protocoles Internet utilisés pour transmettre nos courriels nous assurent déjà de la bonne réception des courriels avec une grande probabilité et un courriel automatisé de réponse ne nous assure pas que le récipiendaire a effectivement pris en compte le courriel. Il est légitime de relancer un destinataire après un délai raisonable pour s\u0026rsquo;assurer que notre envoi a été bien reçu et traité. Par contre, il est normalement considéré impoli et abusif d\u0026rsquo;exiger des accusés de réception.\nLe courriel n\u0026rsquo;est pas toujours le meilleur outil pour obtenir de l\u0026rsquo;information. Il est souvent souhaitable de faire au préalable vos propres recherches. Dans tous les cas, montrez au destinataire que vous avez fait un effort avant d\u0026rsquo;écrire votre courriel.\nLe courriel n\u0026rsquo;est pas, en général, un moyen d\u0026rsquo;échange préservant la confidentialité. Ne transmettez pas vos mots de passe ou toute autre information confidentielle par courriel.\nSi vous écrivez au professeur responsable du cours ou à la personne qui vous encadre, n\u0026rsquo;oubliez d\u0026rsquo;inclure le sigle du cours dans votre courriel ([inf1220]).\n"},{"id":43,"href":"/inf1901-teluq/docs/modules/","title":"Modules","section":"Docs","content":" Modules # Sélectionnez un module dans le menu pour accéder à son contenu:\nModule 1. Algorithme et pseudocode. Dans ce module, vous verrez comment concevoir des algorithmes simples et comment les présenter de manière précise en français. Module 2. Introduction au langage Java. Le concept de programme. Les types, les fonctions, les méthodes, les variables. Les variables de classe et les variables locales. Module 3. Les structures de données, de contrôle et d'itération en Java. Manipulation de chaînes de caractères. Mise en oeuvre d'algorithmes avec des boucles. Module 4. Les entrées et sorties. Module 5. La programmation orientée-objet: héritage et le polymorphisme. "}]