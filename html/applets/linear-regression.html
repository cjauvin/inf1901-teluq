<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Régression Linéaire Interactive</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
    }
    #container {
      max-width: 800px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="container">
    <div style="text-align: center; margin-bottom: 10px;">
      <label for="pointSlider2">Nombre de points : </label>
      <input type="range" id="pointSlider2" min="2" max="50" value="25" style="width: 200px;">
      <span id="pointCount2">25</span>
    </div>
    <canvas id="canvas2"></canvas>
    <div id="info2" style="text-align: center; margin-top: 20px">f(x) = mx + b</div>
  </div>

<script>
// Second widget elements
const canvas2 = document.getElementById("canvas2");
const ctx2 = canvas2.getContext("2d");
const info2 = document.getElementById("info2");
const pointSlider2 = document.getElementById("pointSlider2");
const pointCount2 = document.getElementById("pointCount2");

// Second widget dimensions and variables
let width2, height2, graphWidth2, graphOffsetX2;
let points2 = [];
let anchor2 = { x: 300, y: 200 };
let angle2 = -Math.PI / 4;
let hiddenSlope, hiddenIntercept; // Hidden line parameters

// Second widget drag state
let dragging2 = false;
let dragMode2 = null;
let draggedPointIndex2 = -1;
let mouseDownPos2 = null;
let hasMoved2 = false;

// Touch handling for second widget
let touchStartTime2 = 0;
let touchHoldTimer2 = null;
let touchHoldTriggered2 = false;

// Constants for second widget
const anchorRadius2 = 12;
const innerRadius2 = 11;
const outerRadius2 = 12;

// Initialize second widget
window.addEventListener('load', () => {
  const parentWidth2 = canvas2.parentElement.getBoundingClientRect().width;
  width2 = parentWidth2;
  height2 = Math.round(parentWidth2 * (500 / 780));

  canvas2.width = width2;
  canvas2.height = height2;

  graphWidth2 = Math.min(width2 - 80, width2 * 0.85);
  graphOffsetX2 = 35;

  // Generate hidden line parameters
  hiddenSlope = (Math.random() - 0.5) * 1.5; // Random slope between -0.75 and 0.75
  hiddenIntercept = height2 * 0.3 + Math.random() * height2 * 0.4; // Random intercept in middle range

  anchor2 = { x: (graphWidth2 / 2) + 20, y: height2 / 2 };

  generateRandomPoints2(25);
  draw2();
});

function generateRandomPoints2(numPoints) {
  points2 = [];
  const margin = 20;
  const noiseAmount = 80; // Noise level

  // Calculate safe bounds for the hidden line to ensure all points stay within graph
  const xMin = margin;
  const xMax = graphWidth2 - margin;
  const yMin = margin + noiseAmount / 2;
  const yMax = height2 - margin - noiseAmount / 2;

  // Generate hidden line parameters that ensure points stay within bounds
  // Calculate slope limits based on the safe y range
  const maxSlope = (yMax - yMin) / (xMax - xMin);
  const minSlope = -(yMax - yMin) / (xMax - xMin);

  hiddenSlope = minSlope + Math.random() * (maxSlope - minSlope);

  // Calculate intercept range that works with this slope
  const interceptAtXMin = yMin - hiddenSlope * xMin;
  const interceptAtXMax = yMax - hiddenSlope * xMax;
  const minIntercept = Math.max(interceptAtXMin, interceptAtXMax);
  const maxIntercept = Math.min(yMax - hiddenSlope * xMin, yMin - hiddenSlope * xMax);

  hiddenIntercept = minIntercept + Math.random() * (maxIntercept - minIntercept);

  for (let i = 0; i < numPoints; i++) {
    // Sample x uniformly across the graph width
    const x = Math.random() * (graphWidth2 - 2 * margin) + margin;

    // Calculate ideal y based on hidden line: y = slope * x + intercept
    const idealY = hiddenSlope * x + hiddenIntercept;

    // Add noise that keeps points within bounds
    const noise = (Math.random() - 0.5) * noiseAmount;
    const y = idealY + noise;

    points2.push({ x, y, label: 1 }); // All points are blue (label 1)
  }
}

function drawGrid2(spacing = 25, offsetX = 0) {
  ctx2.strokeStyle = "#eee";
  ctx2.lineWidth = 1;
  for (let x = 0; x <= graphWidth2; x += spacing) {
    ctx2.beginPath();
    ctx2.moveTo(offsetX + x, 0);
    ctx2.lineTo(offsetX + x, height2);
    ctx2.stroke();
  }
  for (let y = 0; y <= height2; y += spacing) {
    ctx2.beginPath();
    ctx2.moveTo(offsetX, y);
    ctx2.lineTo(offsetX + graphWidth2, y);
    ctx2.stroke();
  }
}

function draw2() {
  ctx2.clearRect(0, 0, width2, height2);

  const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;

  // Draw white background for graph area
  ctx2.fillStyle = 'white';
  ctx2.fillRect(graphX2, 0, graphWidth2, height2);

  // Draw border around graph area
  ctx2.strokeStyle = '#aaa';
  ctx2.lineWidth = 1;
  ctx2.strokeRect(graphX2, 0, graphWidth2, height2);

  drawGrid2(25, graphX2);

  // Calculate line coordinates for later drawing
  const dx = Math.cos(angle2);
  const dy = Math.sin(angle2);
  const lineLength = Math.max(width2, height2);
  const x1 = anchor2.x - dx * lineLength;
  const y1 = anchor2.y - dy * lineLength;
  const x2 = anchor2.x + dx * lineLength;
  const y2 = anchor2.y + dy * lineLength;

  // Draw points (all blue)
  points2.forEach(point => {
    ctx2.fillStyle = 'white'; // '#4285f4'; // Blue color
    ctx2.beginPath();
    ctx2.arc(point.x + graphX2, point.y, outerRadius2, 0, 2 * Math.PI);
    ctx2.fill();

    // Draw border
    ctx2.strokeStyle = '#333';
    ctx2.lineWidth = 1;
    ctx2.stroke();
  });

  // Draw anchor point
  ctx2.fillStyle = '#000';
  ctx2.beginPath();
  ctx2.arc(anchor2.x + graphX2, anchor2.y, anchorRadius2, 0, 2 * Math.PI);
  ctx2.fill();

  // ctx2.fillStyle = '#fff';
  // ctx2.beginPath();
  // ctx2.arc(anchor2.x + graphX2, anchor2.y, innerRadius2, 0, 2 * Math.PI);
  // ctx2.fill();

  // Draw user's line on top of points and anchor (dashed)
  ctx2.save();
  ctx2.rect(graphX2, 0, graphWidth2, height2);
  ctx2.clip();

  ctx2.strokeStyle = '#000';
  ctx2.lineWidth = 2;
  ctx2.setLineDash([5, 5]);
  ctx2.beginPath();
  ctx2.moveTo(x1 + graphX2, y1);
  ctx2.lineTo(x2 + graphX2, y2);
  ctx2.stroke();
  ctx2.setLineDash([]);

  ctx2.restore();

  // Calculate and draw mean squared error
  let totalError = 0;
  points2.forEach(point => {
    const lineY = anchor2.y + (point.x - anchor2.x) * Math.tan(angle2);
    const error = Math.pow(point.y - lineY, 2);
    totalError += error;
  });

  const mse = points2.length > 0 ? totalError / points2.length : 0;
  const maxError = 10000; // Reasonable maximum for visualization
  const errorPercentage = Math.min(100, (mse / maxError) * 100);

  // Draw error bar
  const barX2 = graphX2 + graphWidth2 + 20;
  const barY2 = 50;
  const barHeight2 = height2 - 100;
  const barWidth2 = 20;

  ctx2.fillStyle = '#f0f0f0';
  ctx2.fillRect(barX2, barY2, barWidth2, barHeight2);
  ctx2.strokeStyle = '#666';
  ctx2.lineWidth = 1;
  ctx2.strokeRect(barX2, barY2, barWidth2, barHeight2);

  // Draw error level
  const errorHeight2 = (errorPercentage / 100) * barHeight2;
  ctx2.fillStyle = '#ff6b6b';
  ctx2.fillRect(barX2, barY2 + barHeight2 - errorHeight2, barWidth2, errorHeight2);

  // Draw labels
  ctx2.fillStyle = getComputedStyle(document.body).getPropertyValue('--body-font-color') || '#333';
  ctx2.font = '12px sans-serif';
  ctx2.textAlign = 'left';
  ctx2.fillText('Max', barX2 + barWidth2 + 5, barY2 + 5);
  ctx2.fillText('0', barX2 + barWidth2 + 5, barY2 + barHeight2 + 5);

  // Position MSE value to avoid overlap with "Max" label
  const mseY = barY2 + barHeight2 - errorHeight2 + 5;
  const minMseY = barY2 + 20; // Minimum position to avoid overlap with "Max"
  const finalMseY = Math.max(mseY, minMseY);
  ctx2.fillText(`${mse.toFixed(1)}`, barX2 + barWidth2 + 5, finalMseY);

  // Draw "Erreur" label
  ctx2.font = '14px sans-serif';
  ctx2.textAlign = 'center';
  ctx2.fillText('Erreur', barX2 + barWidth2 / 2, barY2 - 10);

  // Update info display
  const slope = -Math.tan(angle2);
  const intercept = -(anchor2.y - slope * anchor2.x);
  const mText = isFinite(slope) ? slope.toFixed(2) : '∞';
  const bText = isFinite(intercept) ? intercept.toFixed(2) : '∞';
  info2.textContent = `f(x) = ${mText}x + ${bText}`;
}

// Handle slider input for second widget
pointSlider2.addEventListener('input', (e) => {
  const numPoints = parseInt(e.target.value);
  pointCount2.textContent = numPoints;
  generateRandomPoints2(numPoints);
  draw2();
});

// Helper function for distance calculation (second widget)
function distance2(p1, p2) {
  return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}

// Mouse event handlers for second widget
canvas2.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const rect = canvas2.getBoundingClientRect();
  const mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;

  mouseDownPos2 = { x: mouse.x, y: mouse.y };
  hasMoved2 = false;

  if (mouse.x < graphX2 || mouse.x > graphX2 + graphWidth2) return;

  const graphMouse = { x: mouse.x - graphX2, y: mouse.y };

  if (e.button === 0) {
    if (distance2(graphMouse, anchor2) <= anchorRadius2) {
      dragging2 = true;
      dragMode2 = 'translate';
      return;
    }

    // Check if clicking on the line for rotation
    const dx = Math.cos(angle2);
    const dy = Math.sin(angle2);
    const px = graphMouse.x - anchor2.x;
    const py = graphMouse.y - anchor2.y;
    const distToLine = Math.abs(dy * px - dx * py);
    if (distToLine < 10) {
      dragging2 = true;
      dragMode2 = 'rotate';
      return;
    }

    // Check if clicking on existing point
    for (let i = 0; i < points2.length; i++) {
      if (distance2(graphMouse, points2[i]) < outerRadius2) {
        // Set up for potential drag (will be removed if no movement detected)
        dragging2 = true;
        dragMode2 = 'point';
        draggedPointIndex2 = i;
        return;
      }
    }

    // Add new blue point
    const constrainedX = Math.max(15, Math.min(graphWidth2 - 15, graphMouse.x));
    const constrainedY = Math.max(15, Math.min(height2 - 15, graphMouse.y));
    points2.push({ x: constrainedX, y: constrainedY, label: 1 });
  } else if (e.button === 2) {
    // Right click: add blue point
    const constrainedX = Math.max(15, Math.min(graphWidth2 - 15, graphMouse.x));
    const constrainedY = Math.max(15, Math.min(height2 - 15, graphMouse.y));
    points2.push({ x: constrainedX, y: constrainedY, label: 1 });
  }

  draw2();
});

canvas2.addEventListener('mousemove', (e) => {
  const rect = canvas2.getBoundingClientRect();
  const mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;
  const graphMouse = { x: mouse.x - graphX2, y: mouse.y };

  if (mouseDownPos2 && distance2(mouse, mouseDownPos2) > 3) {
    hasMoved2 = true;
  }

  if (dragging2) {
    if (dragMode2 === 'translate') {
      // Constrain anchor to graph boundaries
      anchor2.x = Math.max(15, Math.min(graphWidth2 - 15, graphMouse.x));
      anchor2.y = Math.max(15, Math.min(height2 - 15, graphMouse.y));
    } else if (dragMode2 === 'rotate') {
      const dx = graphMouse.x - anchor2.x;
      const dy = graphMouse.y - anchor2.y;
      angle2 = Math.atan2(dy, dx);
    } else if (dragMode2 === 'point' && draggedPointIndex2 >= 0) {
      points2[draggedPointIndex2].x = Math.max(15, Math.min(graphWidth2 - 15, graphMouse.x));
      points2[draggedPointIndex2].y = Math.max(15, Math.min(height2 - 15, graphMouse.y));
    }
    draw2();
  } else {
    // Update cursor based on what's under the mouse
    if (mouse.x < graphX2 || mouse.x > graphX2 + graphWidth2) {
      canvas2.style.cursor = 'default';
      return;
    }

    // Check if over anchor point
    if (distance2(graphMouse, anchor2) <= anchorRadius2) {
      canvas2.style.cursor = 'grab';
      return;
    }

    // Check if over decision line
    const dx = Math.cos(angle2);
    const dy = Math.sin(angle2);
    const px = graphMouse.x - anchor2.x;
    const py = graphMouse.y - anchor2.y;
    const distToLine = Math.abs(dy * px - dx * py);
    if (distToLine < 10) {
      canvas2.style.cursor = 'grab';
      return;
    }

    // Check if over a point
    for (let p of points2) {
      if (distance2(graphMouse, p) < outerRadius2) {
        canvas2.style.cursor = 'grab';
        return;
      }
    }

    // Default cursor for empty space
    canvas2.style.cursor = 'default';
  }
});

canvas2.addEventListener('mouseup', (e) => {
  // Check if it was a click (no movement) on a point to remove it
  if (dragMode2 === 'point' && draggedPointIndex2 >= 0 && !hasMoved2) {
    points2.splice(draggedPointIndex2, 1);
    draw2();
  }

  dragging2 = false;
  dragMode2 = null;
  draggedPointIndex2 = -1;
  mouseDownPos2 = null;
  hasMoved2 = false;
});

canvas2.addEventListener('contextmenu', (e) => {
  e.preventDefault();
});

// Touch event handlers for second widget
function getTouchCoordinates2(e) {
  const rect = canvas2.getBoundingClientRect();
  const touch = e.touches[0] || e.changedTouches[0];
  return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
}

canvas2.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = getTouchCoordinates2(e);
  const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;

  touchStartTime2 = Date.now();
  touchHoldTriggered2 = false;

  mouseDownPos2 = { x: touch.x, y: touch.y };
  hasMoved2 = false;

  if (touch.x < graphX2 || touch.x > graphX2 + graphWidth2) return;

  const graphTouch = { x: touch.x - graphX2, y: touch.y };

  touchHoldTimer2 = setTimeout(() => {
    touchHoldTriggered2 = true;
    for (let i = 0; i < points2.length; i++) {
      if (distance2(graphTouch, points2[i]) < outerRadius2) {
        points2.splice(i, 1);
        draw2();
        return;
      }
    }
    const constrainedX = Math.max(15, Math.min(graphWidth2 - 15, graphTouch.x));
    const constrainedY = Math.max(15, Math.min(height2 - 15, graphTouch.y));
    points2.push({ x: constrainedX, y: constrainedY, label: 1 });
    draw2();
  }, 500);

  if (distance2(graphTouch, anchor2) <= anchorRadius2) {
    dragging2 = true;
    dragMode2 = 'translate';
    return;
  }

  // Check if touching on the line for rotation
  const dx = Math.cos(angle2);
  const dy = Math.sin(angle2);
  const px = graphTouch.x - anchor2.x;
  const py = graphTouch.y - anchor2.y;
  const distToLine = Math.abs(dy * px - dx * py);
  if (distToLine < 10) {
    dragging2 = true;
    dragMode2 = 'rotate';
    return;
  }

  for (let i = 0; i < points2.length; i++) {
    if (distance2(graphTouch, points2[i]) < outerRadius2) {
      dragging2 = true;
      dragMode2 = 'point';
      draggedPointIndex2 = i;
      return;
    }
  }
});

canvas2.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const touch = getTouchCoordinates2(e);
  const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;
  const graphTouch = { x: touch.x - graphX2, y: touch.y };

  if (touchHoldTimer2) {
    clearTimeout(touchHoldTimer2);
    touchHoldTimer2 = null;
  }

  if (mouseDownPos2 && distance2(touch, mouseDownPos2) > 3) {
    hasMoved2 = true;
  }

  if (dragging2) {
    if (dragMode2 === 'translate') {
      // Constrain anchor to graph boundaries
      anchor2.x = Math.max(15, Math.min(graphWidth2 - 15, graphTouch.x));
      anchor2.y = Math.max(15, Math.min(height2 - 15, graphTouch.y));
    } else if (dragMode2 === 'rotate') {
      const dx = graphTouch.x - anchor2.x;
      const dy = graphTouch.y - anchor2.y;
      angle2 = Math.atan2(dy, dx);
    } else if (dragMode2 === 'point' && draggedPointIndex2 >= 0) {
      points2[draggedPointIndex2].x = Math.max(15, Math.min(graphWidth2 - 15, graphTouch.x));
      points2[draggedPointIndex2].y = Math.max(15, Math.min(height2 - 15, graphTouch.y));
    }
    draw2();
  }
});

canvas2.addEventListener('touchend', (e) => {
  e.preventDefault();

  if (touchHoldTimer2) {
    clearTimeout(touchHoldTimer2);
    touchHoldTimer2 = null;
  }

  if (touchHoldTriggered2) {
    dragging2 = false;
    dragMode2 = null;
    draggedPointIndex2 = -1;
    mouseDownPos2 = null;
    hasMoved2 = false;
    return;
  }

  if (!hasMoved2 && Date.now() - touchStartTime2 < 300) {
    const touch = getTouchCoordinates2(e);
    const graphX2 = (width2 - graphWidth2) / 2 - graphOffsetX2;

    if (touch.x >= graphX2 && touch.x <= graphX2 + graphWidth2) {
      const graphTouch = { x: touch.x - graphX2, y: touch.y };

      for (let i = 0; i < points2.length; i++) {
        if (distance2(graphTouch, points2[i]) < outerRadius2) {
          points2.splice(i, 1);
          draw2();
          dragging2 = false;
          dragMode2 = null;
          draggedPointIndex2 = -1;
          mouseDownPos2 = null;
          hasMoved2 = false;
          return;
        }
      }

      const constrainedX = Math.max(15, Math.min(graphWidth2 - 15, graphTouch.x));
      const constrainedY = Math.max(15, Math.min(height2 - 15, graphTouch.y));
      points2.push({ x: constrainedX, y: constrainedY, label: 1 });
      draw2();
    }
  }

  dragging2 = false;
  dragMode2 = null;
  draggedPointIndex2 = -1;
  mouseDownPos2 = null;
  hasMoved2 = false;
});
</script>
<script src="https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js"></script>

</body>
</html>
