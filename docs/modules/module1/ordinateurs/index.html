<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Court historique des langages de programmation
  #

L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://cjauvin.github.io/inf1091-teluq/docs/modules/module1/ordinateurs/"><meta property="og:site_name" content="INF 1901 - Introduction à l'intelligence artificielle"><meta property="og:title" content="Les ordinateurs"><meta property="og:description" content="Court historique des langages de programmation # L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Les ordinateurs | INF 1901 - Introduction à l'intelligence artificielle</title><link rel=icon href=/inf1091-teluq/favicon.png><link rel=manifest href=/inf1091-teluq/manifest.json><link rel=canonical href=https://cjauvin.github.io/inf1091-teluq/docs/modules/module1/ordinateurs/><link rel=stylesheet href=/inf1091-teluq/book.min.bf2f654d6972b0f70425f889d6228f669a1d674c3b860c3a03d341041e2765df.css integrity="sha256-vy9lTWlysPcEJfiJ1iKPZpodZ0w7hgw6A9NBBB4nZd8=" crossorigin=anonymous><script defer src=/inf1091-teluq/fuse.min.js></script><script defer src=/inf1091-teluq/fr.search.min.a765ffc5159c4dc25c6a9b566532b969dacce6b7848831ab5cd51607f32abb30.js integrity="sha256-p2X/xRWcTcJcaptWZTK5adrM5reEiDGrXNUWB/MquzA=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/inf1091-teluq/><span>INF 1901 - Introduction à l'intelligence artificielle</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/inf1091-teluq/docs/credits/>Le professeur</a></li><li><a href=/inf1091-teluq/docs/erreurs/>Vous avez trouvé une erreur?</a></li><li><a href=/inf1091-teluq/docs/feuille-de-route/>Feuille de route</a></li><li><a href=/inf1091-teluq/docs/ressources/>Ressources</a></li><li><a href=/inf1091-teluq/docs/evaluation/>Évaluation</a></li><li><a href=/inf1091-teluq/docs/faq/>FAQ</a></li><li><a href=/inf1091-teluq/docs/math/>Rappel mathématique</a></li><li><a href=/inf1091-teluq/docs/ia/>Intelligence artificielle</a></li><li><a href=/inf1091-teluq/docs/courriel/>Petit guide d’usage du courriel efficace</a></li><li><a href=/inf1091-teluq/docs/modules/>Modules</a><ul><li><a href=/inf1091-teluq/docs/modules/module1/>Module 1: Algorithme et pseudocode</a><ul><li><a href=/inf1091-teluq/docs/modules/module1/teluq/>Modèle du cours</a></li><li><a href=/inf1091-teluq/docs/modules/module1/robot/>Robot conversationnel et intelligence artificielle</a></li><li><a href=/inf1091-teluq/docs/modules/module1/ordinateurs/ class=active>Les ordinateurs</a></li><li><a href=/inf1091-teluq/docs/modules/module1/algorithmes/>Les algorithmes</a></li><li><a href=/inf1091-teluq/docs/modules/module1/exercices/>Exercices sur les algorithmes</a></li><li><a href=/inf1091-teluq/docs/modules/module1/travail-note-1/>Travail noté 1</a></li></ul></li><li><a href=/inf1091-teluq/docs/modules/module2/>Module 2: Introduction à l'apprentissage machine</a><ul><li><a href=/inf1091-teluq/docs/modules/module2/preparation/>Préparation de l’espace de travail</a></li><li><a href=/inf1091-teluq/docs/modules/module2/oriente/>Qu’est-ce qu’un langage de programmation orientée-objet?</a></li><li><a href=/inf1091-teluq/docs/modules/module2/typeoperateur/>Introduction aux types de base et à leurs opérateurs.</a></li><li><a href=/inf1091-teluq/docs/modules/module2/exercices-2-1/>Exercices 2.1</a></li><li><a href=/inf1091-teluq/docs/modules/module2/activite-2-4/>Activité 2.4</a></li><li><a href=/inf1091-teluq/docs/modules/module2/exercices-2-2/>Exercices 2.2</a></li><li><a href=/inf1091-teluq/docs/modules/module2/travail-note-2/>Travail noté 2</a></li></ul></li><li><a href=/inf1091-teluq/docs/modules/module3/>Module 3: Les structures de données, de contrôle et d'itération en Java</a><ul><li><a href=/inf1091-teluq/docs/modules/module3/activite-3-1/>Activité 3.1</a></li><li><a href=/inf1091-teluq/docs/modules/module3/activite-3-2/>Activité 3.2</a></li><li><a href=/inf1091-teluq/docs/modules/module3/activite-3-3/>Activité 3.3</a></li><li><a href=/inf1091-teluq/docs/modules/module3/exercices-3-1/>Exercices 3.1</a></li><li><a href=/inf1091-teluq/docs/modules/module3/travail-note-3/>Travail noté 3</a></li><li><a href=/inf1091-teluq/docs/modules/module3/activite-3-4/>Activité 3.4</a></li><li><a href=/inf1091-teluq/docs/modules/module3/activite-3-5/>Activité 3.5</a></li></ul></li><li><a href=/inf1091-teluq/docs/modules/module4/>Module 4: Les entrées et sorties</a><ul><li><a href=/inf1091-teluq/docs/modules/module4/activite-4-1/>Activité 4.1</a></li><li><a href=/inf1091-teluq/docs/modules/module4/activite-4-2/>Activité 4.2</a></li><li><a href=/inf1091-teluq/docs/modules/module4/exercices-4-1/>Exercices 4.1</a></li><li><a href=/inf1091-teluq/docs/modules/module4/travail-note-4/>Travail noté 4</a></li></ul></li><li><a href=/inf1091-teluq/docs/modules/module5/>Module 5. La programmation orientée-objet: héritage et le polymorphisme</a><ul><li><a href=/inf1091-teluq/docs/modules/module5/activite-5-1/>Activité 5.1</a></li><li><a href=/inf1091-teluq/docs/modules/module5/activite-5-2/>Activité 5.2</a></li><li><a href=/inf1091-teluq/docs/modules/module5/exercices-5-1/>Exercices 5.1</a></li><li><a href=/inf1091-teluq/docs/modules/module5/travail-note-5/>Travail noté 5</a></li></ul></li><li><a href=/inf1091-teluq/docs/modules/examen/>Examen</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/inf1091-teluq/svg/menu.svg class=book-icon alt=Menu></label><h3>Les ordinateurs</h3><label for=toc-control><img src=/inf1091-teluq/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#court-historique-des-langages-de-programmation>Court historique des langages de programmation</a></li><li><a href=#résumé-de-larchitecture-des-ordinateurs-et-de-labstraction-des-langages>Résumé de l’architecture des ordinateurs et de l’abstraction des langages</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h3 id=court-historique-des-langages-de-programmation>Court historique des langages de programmation
<a class=anchor href=#court-historique-des-langages-de-programmation>#</a></h3><p>L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière.</p><p>L’avènement des ordinateurs modernes dans les années 1940-1950 marque un tournant décisif. Les premiers langages de programmation apparaissent pour répondre aux besoins de calcul scientifique, commercial et logique. Parmi eux, FORTRAN (1954) facilite les calculs scientifiques, LISP (1958) introduit des concepts d’intelligence artificielle et de traitement symbolique, et COBOL (1959) s’impose dans la gestion des données commerciales. Ces langages, bien que rudimentaires comparés aux standards actuels, posent les bases des paradigmes de programmation modernes.</p><p>Au fil des décennies, les langages évoluent pour offrir plus d’abstraction, de flexibilité et d’accessibilité. Dans les années 1980 et 1990, des langages comme C++ (1983), Python (1991), Java (1995), JavaScript (1995) et PHP (1995) voient le jour, chacun répondant à des besoins spécifiques : performance pour C++, simplicité pour Python, portabilité pour Java, interactivité web pour JavaScript, ou développement web dynamique pour PHP. Aujourd’hui, ces langages dominent l’industrie, comme le montre le classement 2017 de l’IEEE Spectrum, qui reflète leur popularité et leur polyvalence.</p><p>Tous ces langages partagent un objectif commun : permettre aux programmeurs de décrire des solutions à des problèmes en s’éloignant progressivement des contraintes du matériel. Pour comprendre leur rôle, il est essentiel de se pencher sur le fonctionnement des ordinateurs.</p><h3 id=résumé-de-larchitecture-des-ordinateurs-et-de-labstraction-des-langages>Résumé de l’architecture des ordinateurs et de l’abstraction des langages
<a class=anchor href=#r%c3%a9sum%c3%a9-de-larchitecture-des-ordinateurs-et-de-labstraction-des-langages>#</a></h3><p>Les ordinateurs modernes s’appuient sur deux concepts fondamentaux : la machine de Turing, théorisée par Alan Turing, qui définit une machine capable d’exécuter n’importe quel algorithme, et l’architecture de von Neumann, qui structure les ordinateurs autour de quatre composantes principales. Premièrement, la mémoire stocke à la fois les données et les programmes, une innovation clé par rapport aux machines antérieures où les instructions étaient fixes. Deuxièmement, l’unité de contrôle orchestre l’exécution des instructions en suivant un séquençage précis. Troisièmement, l’unité arithmétique et logique effectue les calculs de base, comme les additions ou les comparaisons. Enfin, les interfaces d’entrée/sortie permettent d’interagir avec l’utilisateur ou d’autres systèmes, via des périphériques comme les claviers, écrans ou réseaux.</p><p>Dans un langage plus accessible, un ordinateur contemporain se compose de processeurs (CPU), de mémoire vive (RAM) pour les calculs temporaires, de stockage à long terme (disques durs ou SSD), de processeurs graphiques (GPU) pour le rendu visuel, et de cartes d’entrée/sortie pour la connectivité. La carte mère agit comme un chef d’orchestre, coordonnant les échanges entre ces éléments. Par exemple, lorsqu’un programme s’exécute, le CPU lit les instructions depuis la RAM, effectue les calculs nécessaires, et envoie les résultats vers la mémoire ou un périphérique de sortie, comme un écran.</p><p>Les processeurs se déclinent en plusieurs architectures. Dans les ordinateurs personnels, les puces x64 (ou x86-64), produites par Intel et AMD, dominent grâce à leur puissance et leur compatibilité. Dans les appareils mobiles, comme les smartphones, les processeurs ARM, plus économes en énergie, sont privilégiés. La mémoire vive repose sur la technologie DRAM, rapide mais volatile, tandis que le stockage à long terme utilise majoritairement la mémoire flash, comme dans les SSD, pour sa rapidité et sa fiabilité.</p><p>Les langages de programmation jouent un rôle crucial en traduisant des instructions humaines en commandes compréhensibles par ces composants matériels. Leur niveau d’abstraction varie : les langages de bas niveau, comme l’assembleur, sont proches du matériel et offrent un contrôle précis mais exigent une expertise technique. À l’opposé, les langages de haut niveau, comme Python ou Java, simplifient le développement en masquant les détails matériels, ce qui les rend plus accessibles et adaptés à des applications complexes, comme le développement web ou l’intelligence artificielle.</p><p>Dans ce cours, nous explorerons le langage Java, largement adopté dans l’industrie pour sa portabilité, sa robustesse et sa polyvalence. Utilisé dans des domaines variés, des applications mobiles Android aux systèmes d’entreprise, Java illustre parfaitement comment un langage de haut niveau peut répondre à des besoins modernes tout en s’appuyant sur les principes fondamentaux de l’informatique.</p><h3>Java pas à pas</h3><p>Nous vous invitons maintenant à lire le chapitre 1 du manuel Java Pas à Pas. Vous devez <a href=https://github.com/RobertGodin/JavaPasAPas/raw/master/JavaPasAPas.pdf>charger le document PDF</a>.</p><img src=https://m.media-amazon.com/images/I/61tnblFlmmL._SL1499_.jpg alt="Couverture du manuel Java pas à pas" width=35%></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#court-historique-des-langages-de-programmation>Court historique des langages de programmation</a></li><li><a href=#résumé-de-larchitecture-des-ordinateurs-et-de-labstraction-des-langages>Résumé de l’architecture des ordinateurs et de l’abstraction des langages</a></li></ul></li></ul></nav></div></aside></main></body></html>