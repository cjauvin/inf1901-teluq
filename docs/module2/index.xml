<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Module 2 - Apprentissage automatique on INF1901 - Initiation à l'IA : concepts et réflexions</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/</link><description>Recent content in Module 2 - Apprentissage automatique on INF1901 - Initiation à l'IA : concepts et réflexions</description><generator>Hugo</generator><language>fr</language><atom:link href="https://cjauvin.github.io/inf1901-teluq/docs/module2/index.xml" rel="self" type="application/rss+xml"/><item><title>Un scénario réaliste</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/sc%C3%A9nario-r%C3%A9el/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/sc%C3%A9nario-r%C3%A9el/</guid><description>&lt;h1 id="un-scénario-imaginaire-mais-réaliste-"&gt;
 Un scénario imaginaire, mais réaliste !
 &lt;a class="anchor" href="#un-sc%c3%a9nario-imaginaire-mais-r%c3%a9aliste-"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Imaginez une compagnie où il y a une chaîne de montage avec laquelle on assemble
des téléviseurs.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cjauvin.github.io/inf1901-teluq/images/module2/tv_assembly_line.png" alt="" /&gt;&lt;/p&gt;
&lt;h2 id="le-problème"&gt;
 Le problème
 &lt;a class="anchor" href="#le-probl%c3%a8me"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Supposons que dans un endroit particulièrement délicat de la chaîne de montage,
un problème avec un appareil d&amp;rsquo;assemblage particulier survienne parfois, que
l&amp;rsquo;on aimerait détecter le plus rapidement possible.&lt;/p&gt;
&lt;h2 id="une-solution-possible"&gt;
 Une solution possible
 &lt;a class="anchor" href="#une-solution-possible"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;On pourrait imaginer placer une caméra vidéo dont le but serait de visionner en
permanence le flot des appareils en cours d&amp;rsquo;assemblage, pour tenter de détecter
les problèmes. Pour ce faire, la caméra pourrait transmettre, à intervalles
réguliers, les pixels de ce qu&amp;rsquo;elle capte, en tant que données à un modèle
d&amp;rsquo;apprentissage automatique qui roulerait (en tant que programme) sur un
serveur, pas très éloigné. Ce modèle convertirait les pixels de la caméra en
tant que données numériques (les entrées, &amp;ldquo;inputs&amp;rdquo;), et effectuerait un calcul
complexe sur ces valeurs, en vue de produire une valeur de sortie simple
(&amp;ldquo;outputs&amp;rdquo;) : &amp;ldquo;oui, il y a un problème avec cette image&amp;rdquo;, ou &amp;ldquo;non, il n&amp;rsquo;y a pas
de problème avec cette image&amp;rdquo; (ou encore, ce qui serait équivalent mais plus
simple : &amp;ldquo;ok&amp;rdquo; ou &amp;ldquo;problème&amp;rdquo;). Cette valeur est &lt;em&gt;binaire&lt;/em&gt;, dans le sens qu&amp;rsquo;elle a
seulement deux valeurs possibles (peu importe lesquelles, en autant qu&amp;rsquo;il y en
ait seulement deux). Sur la base de cette valeur binaire de sortie, on pourrait
agir et envoyer un technicien, en cas de besoin, pour régler le problème.&lt;/p&gt;</description></item><item><title>AA versus X</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/diff%C3%A9rence-avec-x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/diff%C3%A9rence-avec-x/</guid><description>&lt;h2 id="en-quoi-lapprentissage-automatique-diffère-de-la-programmation-au-sens-traditionnel"&gt;
 En quoi l&amp;rsquo;apprentissage automatique diffère de la programmation au sens traditionnel?
 &lt;a class="anchor" href="#en-quoi-lapprentissage-automatique-diff%c3%a8re-de-la-programmation-au-sens-traditionnel"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bien que l&amp;rsquo;apprentissage automatique requiert de la programmation, il s&amp;rsquo;agit
d&amp;rsquo;un paradigme entièrement différent de celui de la programmation.&lt;/p&gt;
&lt;p&gt;Un programme traditionnel spécifie une série d&amp;rsquo;instructions que l&amp;rsquo;ordinateur
exécute pour résoudre un problème. Normalement, ce programme fait son travail en
relation avec des données fournies par l&amp;rsquo;utilisateur. Le programme dans ce cas
est une série d&amp;rsquo;instructions symboliques dans un langage de programmation.&lt;/p&gt;</description></item><item><title>Que sont les données?</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/les-donn%C3%A9es/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/les-donn%C3%A9es/</guid><description>&lt;h1 id="que-sont-les-données-et-comment-les-représenter"&gt;
 Que sont les données, et comment les représenter?
 &lt;a class="anchor" href="#que-sont-les-donn%c3%a9es-et-comment-les-repr%c3%a9senter"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Il y a une tension fondamentale en informatique entre les différentes manières
de représenter les données, et ce qu&amp;rsquo;elles peuvent signifier. Quand on ajoute
l&amp;rsquo;apprentissage automatique, la situation devient encore plus complexe. Tentons
de clarifier le tout.&lt;/p&gt;
&lt;h2 id="niveau-des-bits-physiques-et-mathématiques"&gt;
 Niveau des bits, physiques et mathématiques
 &lt;a class="anchor" href="#niveau-des-bits-physiques-et-math%c3%a9matiques"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Au niveau le plus fondamental, l&amp;rsquo;ordinateur, physiquement et logiquement, ne
peut traiter qu&amp;rsquo;un seul type de donnée : le bit, qui est à la fois un concept
mathématique (un symbole dont la valeur ne peut être que &lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt; généralement, ou
&lt;code&gt;vrai&lt;/code&gt; ou &lt;code&gt;faux&lt;/code&gt; plus spécifiquement en logique) et physique, au niveau de
l&amp;rsquo;implémentation, soit en terme électrique (mémoire RAM, CPU, disque SSD), de
magnétisme (disque dur) ou de caractéristiques optiques (CD). Les bits
&lt;em&gt;représentent&lt;/em&gt; les nombres via la convention de l&amp;rsquo;encodage binaire.&lt;/p&gt;</description></item><item><title>Qu'est-ce qu'un modèle?</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/mod%C3%A8les/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/mod%C3%A8les/</guid><description>&lt;h1 id="quest-ce-quon-veut-dire-par-modèle"&gt;
 Qu&amp;rsquo;est-ce qu&amp;rsquo;on veut dire par modèle?
 &lt;a class="anchor" href="#quest-ce-quon-veut-dire-par-mod%c3%a8le"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Le mot &amp;ldquo;modèle&amp;rdquo; est polysémique et peut prêter à confusion selon qu’on parle d’apprentissage automatique, de statistiques, de sciences ou de mathématiques pures. Ce chapitre clarifie ces sens et propose un vocabulaire pratique pour les distinguer dans le contexte de ce cours.&lt;/p&gt;
&lt;h2 id="le-sens-central-en-apprentissage-automatique"&gt;
 Le sens central en apprentissage automatique
 &lt;a class="anchor" href="#le-sens-central-en-apprentissage-automatique"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Dans l’AA, un modèle est avant tout une fonction paramétrée qui prend des données en entrée et produit une sortie utile (prédiction, score, probabilité, texte, etc.) :&lt;/p&gt;</description></item><item><title>Les paradigmes de l'AA</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/les-paradigmes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/les-paradigmes/</guid><description>&lt;h1 id="les-différents-paradigmes-de-lapprentissage-automatique"&gt;
 Les différents paradigmes de l&amp;rsquo;apprentissage automatique
 &lt;a class="anchor" href="#les-diff%c3%a9rents-paradigmes-de-lapprentissage-automatique"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Il existe plusieurs manières de catégoriser les algorithmes d&amp;rsquo;apprentissage
automatique, selon leur nature et la structure des problèmes qu&amp;rsquo;ils tentent de
résoudre. Nous allons brièvement discuter de trois schémas de classement :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;apprentissage &lt;em&gt;supervisé&lt;/em&gt; versus &lt;em&gt;non-supervisé&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;apprentissage &lt;em&gt;paramétrique&lt;/em&gt; versus &lt;em&gt;non-paramétrique&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;apprentissage &lt;em&gt;inductif&lt;/em&gt; versus &lt;em&gt;transductif&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nous allons également parler de l&amp;rsquo;&lt;em&gt;apprentissage par renforcement&lt;/em&gt;, qui est dans
une classe à part.&lt;/p&gt;
&lt;h2 id="apprentissage-supervisé-versus-non-supervisé"&gt;
 Apprentissage supervisé versus non-supervisé
 &lt;a class="anchor" href="#apprentissage-supervis%c3%a9-versus-non-supervis%c3%a9"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;La distinction la plus connue oppose l’apprentissage supervisé à l’apprentissage non-supervisé.&lt;/p&gt;</description></item><item><title>Apprentissage supervisé</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/apprentissage-supervis%C3%A9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/apprentissage-supervis%C3%A9/</guid><description>&lt;h1 id="apprentissage-supervisé"&gt;
 Apprentissage supervisé
 &lt;a class="anchor" href="#apprentissage-supervis%c3%a9"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;L&amp;rsquo;apprentissage supervisé fonctionne à partir de données pour lesquelles la
&amp;ldquo;bonne réponse&amp;rdquo; (i.e. celle qu&amp;rsquo;on aimerait que l&amp;rsquo;algorithme fournisse
systématiquement, une fois entraîné) est fournie, en tant que donnée
d’entraînement. L&amp;rsquo;apprentissage supervisé correspond à la notion intuitive qu&amp;rsquo;on
a de l&amp;rsquo;enseignement et de l&amp;rsquo;apprentissage : un enseignant qui pose une question
à un étudiant est en mesure de le corriger en lui indiquant si sa réponse est
correcte ou non (car l&amp;rsquo;enseignant connaît, à priori, la &amp;ldquo;bonne réponse&amp;rdquo; à sa
propre question).&lt;/p&gt;</description></item><item><title>Travail noté 2</title><link>https://cjauvin.github.io/inf1901-teluq/docs/module2/travail-not%C3%A9-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1901-teluq/docs/module2/travail-not%C3%A9-2/</guid><description>&lt;h1 id="classification-naïve-bayésienne-pour-détecter-les-pourriels-travail-noté-2"&gt;
 Classification naïve bayésienne pour détecter les pourriels (travail noté 2)
 &lt;a class="anchor" href="#classification-na%c3%afve-bay%c3%a9sienne-pour-d%c3%a9tecter-les-pourriels-travail-not%c3%a9-2"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;La classification naïve bayésienne est un algorithme d&amp;rsquo;apprentissage supervisé
qui fonctionne avec les probabilités. Nous avons vu deux variantes de cet
algorithme :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://cjauvin.github.io/inf1901-teluq/docs/module2/apprentissage-supervis%C3%A9/#classification-bayésienne-naive-gaussienne"&gt;La classification de simples points en 2d avec un modèle gaussien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cjauvin.github.io/inf1901-teluq/docs/module2/apprentissage-supervis%C3%A9/#classification-bayésienne-naive-multinomiale"&gt;La classification de vecteurs en haute dimension avec un modèle multinomial&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Un problème classique qui peut être traité avec cet algorithme est la
classification de courriels. On peut tenter d&amp;rsquo;estimer la probabilité qu&amp;rsquo;un
courriel soit en fait un pourriel en prenant en compte les mots particuliers
qu&amp;rsquo;il contient, l&amp;rsquo;idée étant que certains mots auront tendance à être plus
souvent utilisés selon qu&amp;rsquo;il s&amp;rsquo;agit d&amp;rsquo;un pourriel ou d&amp;rsquo;un courriel.&lt;/p&gt;</description></item></channel></rss>