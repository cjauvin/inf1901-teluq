<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Que sont les données, et comment les représenter?
  #

Il y a une tension fondamentale en informatique entre les différentes manières
de représenter les données, et ce qu&rsquo;elles peuvent signifier. Quand on ajoute
l&rsquo;apprentissage automatique, la situation devient encore plus complexe. Tentons
de clarifier le tout.

  Niveau des bits, physiques et mathématiques
  #

Au niveau le plus fondamental, l&rsquo;ordinateur, physiquement et logiquement, ne
peut traiter qu&rsquo;un seul type de donnée : le bit, qui est à la fois un concept
mathématique (un symbole dont la valeur ne peut être que 0 ou 1 généralement, ou
vrai ou faux plus spécifiquement en logique) et physique, au niveau de
l&rsquo;implémentation, soit en terme électrique (mémoire RAM, CPU, disque SSD), de
magnétisme (disque dur) ou de caractéristiques optiques (CD). Les bits
représentent les nombres via la convention de l&rsquo;encodage binaire."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://cjauvin.github.io/inf1901-teluq/docs/module2/les-donn%C3%A9es/"><meta property="og:site_name" content="INF1901 - Initiation à l'IA : concepts et réflexions"><meta property="og:title" content="Que sont les données?"><meta property="og:description" content="Que sont les données, et comment les représenter? # Il y a une tension fondamentale en informatique entre les différentes manières de représenter les données, et ce qu’elles peuvent signifier. Quand on ajoute l’apprentissage automatique, la situation devient encore plus complexe. Tentons de clarifier le tout.
Niveau des bits, physiques et mathématiques # Au niveau le plus fondamental, l’ordinateur, physiquement et logiquement, ne peut traiter qu’un seul type de donnée : le bit, qui est à la fois un concept mathématique (un symbole dont la valeur ne peut être que 0 ou 1 généralement, ou vrai ou faux plus spécifiquement en logique) et physique, au niveau de l’implémentation, soit en terme électrique (mémoire RAM, CPU, disque SSD), de magnétisme (disque dur) ou de caractéristiques optiques (CD). Les bits représentent les nombres via la convention de l’encodage binaire."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Que sont les données? | INF1901 - Initiation à l'IA : concepts et réflexions</title><link rel=icon href=https://cjauvin.github.io/inf1901-teluq/images/paperclip-logo.png><link rel=manifest href=https://cjauvin.github.io/inf1901-teluq/manifest.json><link rel=canonical href=https://cjauvin.github.io/inf1901-teluq/docs/module2/les-donn%C3%A9es/><link rel=stylesheet href=https://cjauvin.github.io/inf1901-teluq/book.min.c2a3a3930cc3c92484d4c7886a609454c1ccc7fbe839b6904dde85b081e514b4.css integrity="sha256-wqOjkwzDySSE1MeIamCUVMHMx/voObaQTd6FsIHlFLQ=" crossorigin=anonymous><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=https://cjauvin.github.io/inf1901-teluq/><img src=https://cjauvin.github.io/inf1901-teluq/images/paperclip-logo.png alt=Logo class=book-icon><span>INF1901 - Initiation à l'IA : concepts et réflexions</span></a></h2><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/pr%C3%A9sentation/>Présentation du cours</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/philosophie/>Approche pédagogique du cours</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/professeurs/>Les professeurs</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/livres/>Les livres</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/travaux-not%C3%A9s/>Travaux notés</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/feuille-de-route/>Feuille de route</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/google-sheets/>Google Sheets</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/assistants-intelligents/>Usage de l'IA</a></li><li><input type=checkbox id=section-8907ef67e4ecdf3db52171242f091373 class=toggle>
<label for=section-8907ef67e4ecdf3db52171242f091373 class=flex><a href=https://cjauvin.github.io/inf1901-teluq/docs/module1/ class=flex-auto>Module 1 - Intelligence artificielle</a></label><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module1/activit%C3%A9s/>Activités</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module1/travail-not%C3%A9-1/>Travail noté 1</a></li></ul></li><li><input type=checkbox id=section-0e47afea11237f1612150a31e7123755 class=toggle checked>
<label for=section-0e47afea11237f1612150a31e7123755 class=flex><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/ class=flex-auto>Module 2 - Apprentissage automatique</a></label><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/sc%C3%A9nario-r%C3%A9el/>Un scénario réaliste</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/diff%C3%A9rence-avec-x/>AA versus X</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/les-donn%C3%A9es/ class=active>Que sont les données?</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/mod%C3%A8les/>Qu'est-ce qu'un modèle?</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/les-paradigmes/>Les paradigmes de l'AA</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/apprentissage-supervis%C3%A9/>Apprentissage supervisé</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/travail-not%C3%A9-2/>Travail noté 2</a></li></ul></li><li><input type=checkbox id=section-9cc60359ac12343378e5fa944b3863f7 class=toggle>
<label for=section-9cc60359ac12343378e5fa944b3863f7 class=flex><a href=https://cjauvin.github.io/inf1901-teluq/docs/module3/ class=flex-auto>Module 3 - Réseaux de neurones et apprentissage profond</a></label><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module3/01-r%C3%A9seaux-de-neurones/>Les réseaux de neurones</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module3/02-3blue1brown/>3Blue1Brown</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module3/travail-not%C3%A9-3/>Travail noté 3</a></li></ul></li><li><input type=checkbox id=section-d23b9c643b16319dcdaeed5376bcec9c class=toggle>
<label for=section-d23b9c643b16319dcdaeed5376bcec9c class=flex><a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/ class=flex-auto>Module 4 - IA générative et grands modèles de langage</a></label><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/01-ia-g%C3%A9n%C3%A9rative/>IA générative</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/02-grands-mod%C3%A8les-de-langage/>Grands modèles de langage</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/03-3blue1brown/>3Blue1Brown</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/travail-not%C3%A9-4/>Travail noté 4</a></li></ul></li><li><input type=checkbox id=section-b90ca6a3362bb22be66d4f5e1f8ab16c class=toggle>
<label for=section-b90ca6a3362bb22be66d4f5e1f8ab16c class=flex><a href=https://cjauvin.github.io/inf1901-teluq/docs/module5/ class=flex-auto>Module 5 - Autour de l'IA</a></label><ul><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module5/attitudes/>Attitudes à l'égard de l'IA</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module5/conversation/>Conversation synoptique autour de l'IA</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/module5/travail-not%C3%A9-5/>Travail noté 5</a></li></ul></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/ressources-additionnelles/>Ressources supplémentaires</a></li><li><a href=https://cjauvin.github.io/inf1901-teluq/docs/conclusion/>Conclusion</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://cjauvin.github.io/inf1901-teluq/svg/menu.svg class=book-icon alt=Menu></label><h3>Que sont les données?</h3><label for=toc-control><img src=https://cjauvin.github.io/inf1901-teluq/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#niveau-des-bits-physiques-et-mathématiques>Niveau des bits, physiques et mathématiques</a></li><li><a href=#niveau-de-lordinateur-et-de-son-langage>Niveau de l&rsquo;ordinateur et de son langage</a></li><li><a href=#niveau-de-la-programmation-symbolique>Niveau de la programmation symbolique</a></li><li><a href=#niveau-de-lapprentissage-automatique-et-des-mathématiques>Niveau de l&rsquo;apprentissage automatique et des mathématiques</a><ul><li><a href=#les-gpus>Les GPUs</a></li><li><a href=#retour-vers-les-symboles>Retour vers les symboles</a></li><li><a href=#les-mots-et-leur-sens>Les mots et leur sens</a><ul><li><a href=#lespace-lexical-vectoriel>L’espace lexical vectoriel</a></li><li><a href=#encodage-dun-document-sac-de-mots>Encodage d’un document (sac de mots)</a></li><li><a href=#limites-du-sac-de-mots>Limites du sac de mots</a></li><li><a href=#vers-des-représentations-plus-compactes--les-plongements-lexicaux>Vers des représentations plus compactes : les plongements lexicaux</a></li><li><a href=#exemple-intuitif>Exemple intuitif</a></li><li><a href=#résumé>Résumé</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=que-sont-les-données-et-comment-les-représenter>Que sont les données, et comment les représenter?
<a class=anchor href=#que-sont-les-donn%c3%a9es-et-comment-les-repr%c3%a9senter>#</a></h1><p>Il y a une tension fondamentale en informatique entre les différentes manières
de représenter les données, et ce qu&rsquo;elles peuvent signifier. Quand on ajoute
l&rsquo;apprentissage automatique, la situation devient encore plus complexe. Tentons
de clarifier le tout.</p><h2 id=niveau-des-bits-physiques-et-mathématiques>Niveau des bits, physiques et mathématiques
<a class=anchor href=#niveau-des-bits-physiques-et-math%c3%a9matiques>#</a></h2><p>Au niveau le plus fondamental, l&rsquo;ordinateur, physiquement et logiquement, ne
peut traiter qu&rsquo;un seul type de donnée : le bit, qui est à la fois un concept
mathématique (un symbole dont la valeur ne peut être que <code>0</code> ou <code>1</code> généralement, ou
<code>vrai</code> ou <code>faux</code> plus spécifiquement en logique) et physique, au niveau de
l&rsquo;implémentation, soit en terme électrique (mémoire RAM, CPU, disque SSD), de
magnétisme (disque dur) ou de caractéristiques optiques (CD). Les bits
<em>représentent</em> les nombres via la convention de l&rsquo;encodage binaire.</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/binary_enc.png alt></p><h2 id=niveau-de-lordinateur-et-de-son-langage>Niveau de l&rsquo;ordinateur et de son langage
<a class=anchor href=#niveau-de-lordinateur-et-de-son-langage>#</a></h2><p>Au niveau suivant, on trouve l&rsquo;ordinateur lui-même, dont le mécanisme central
est le microprocesseur (CPU). Un CPU traite les bits sous leur forme physique,
et il interprète des &ldquo;paquets&rdquo; (ou <em>mots</em>) de bits de taille déterminée (souvent
32, 64 ou 128 bits) de deux manière fondamentalement différentes :</p><ol><li>En tant que <em>nombre</em> (ou plus généralement <em>valeur</em>)</li><li>En tant qu&rsquo;<em>instruction</em></li></ol><p>Le flot de bits auquel est exposé le CPU (soit via sa mémoire physique, ou via
un autre médium physique comme un disque) constitue un <em>programme</em>, et le CPU
<em>exécute</em> ce programme, de manière séquentielle et dynamique. Un programme dans
un &ldquo;langage machine&rdquo; (le langage du CPU) fictif pourrait être par exemple :</p><pre tabindex=0><code>MOV 1000
ADD 0001
STR 2000
</code></pre><p>Les symboles <code>MOV</code>, <code>ADD</code> et <code>STR</code> sont des instructions, qui correspondent en fait
elles-mêmes à des nombres (donc des séries de bits). En réalité, le CPU verrait peut-être
la séquence suivante :</p><pre tabindex=0><code>1000 1000
1001 0001
1002 2000
</code></pre><p>si <code>MOV</code>, <code>ADD</code> et <code>STR</code> correspondaient par convention aux valeurs 1000, 1001
et 1002. La signification de ce programme pourrait être la suivante :</p><pre tabindex=0><code>- Prendre la valeur à l&#39;adresse mémoire 1000 et la mettre dans un registre
- Ajouter 1 à cette valeur dans le registre
- Prendre le contenu du registre et l&#39;enregistrer à l&#39;adresse mémoire 2000
</code></pre><p>Comment le CPU peut-il distinguer entre 1000 en tant qu&rsquo;instruction <code>MOV</code>, ou
1000 en tant que valeur? Une manière simple serait de simplement respecter la
convention selon laquelle les &ldquo;paquets de bits&rdquo; (de taille fixe) aux positions
paires (dans la séquence du programme) sont des instructions, tandis que ceux
aux positions impaires sont des valeurs (dans la réalité c&rsquo;est un peu plus
complexe, mais l&rsquo;idée est semblable, il s&rsquo;agit de conventions préétablies). Et
qu&rsquo;est-ce que le CPU doit &ldquo;faire&rdquo; pour exécuter une instruction particulière? Il
s&rsquo;agit en fait d&rsquo;un mini-programme (pour cette instruction particulière) qui est
implémenté directement dans les circuits du CPU. C&rsquo;est l&rsquo;endroit où la logique
et la matière se touchent !</p><p>Vous pouvez exécuter vous-même pas à pas une version interactive de ce
mini-programme :</p><style>ul.instructions{list-style:none;padding:0;margin-bottom:1rem}ul.instructions li{padding:.3rem .6rem;border:1px solid #ccc;border-radius:4px;margin-bottom:.3rem}ul.instructions li.current{background-color:rgba(33,150,243,.2);border-color:#2196f3;color:inherit}.row{display:flex;align-items:center;margin-bottom:.5rem}.row label{width:130px;font-weight:700}.row span{display:inline-block;width:90px;text-align:right;padding:.3rem .5rem;border:1px solid #888;border-radius:4px}.buttons{margin-top:1rem}button{padding:.5rem 1.2rem;margin-right:.5rem}button:disabled{opacity:.5;cursor:not-allowed}</style><ul class=instructions><li data-op=MOV data-arg=1000>MOV 1000</li><li data-op=ADD data-arg=1>ADD 0001</li><li data-op=STR data-arg=2000>STR 2000</li></ul><div class=row><label>Registre&nbsp;:</label><span id=reg></span></div><div class=row><label>Adresse 1000&nbsp;:</label><span id=mem1000></span></div><div class=row><label>Adresse 2000&nbsp;:</label><span id=mem2000></span></div><div class=buttons><button id=execBtn>Exécuter</button>
<button id=resetBtn>Réinitialiser</button></div><script>(function(){const n=[...document.querySelectorAll(".instructions li")],s=document.getElementById("mem1000"),o=document.getElementById("mem2000"),t=document.getElementById("reg"),i=document.getElementById("execBtn"),l=document.getElementById("resetBtn");let e=0;function a(){n.forEach((t,n)=>t.classList.toggle("current",n===e))}function r(){i.disabled=e>=n.length}function c(){s.textContent=Math.floor(Math.random()*256),t.textContent="_",o.textContent="_",e=0,a(),r()}function d(){if(e>=n.length)return;const i=n[e],c=i.dataset.op,l=parseInt(i.dataset.arg,10);switch(c){case"MOV":t.textContent=s.textContent||"0";break;case"ADD":t.textContent=parseInt(t.textContent||"0",10)+l;break;case"STR":o.textContent=t.textContent;break}e++,a(),r()}i.addEventListener("click",d),l.addEventListener("click",c),c()})()</script><h2 id=niveau-de-la-programmation-symbolique>Niveau de la programmation symbolique
<a class=anchor href=#niveau-de-la-programmation-symbolique>#</a></h2><p>Le prochain niveau est implémenté en terme du langage du niveau précédent : tout
comme il est possible d&rsquo;écrire un jeu, un système d&rsquo;exploitation ou tout autre
type de programme dans le langage natif du CPU (le langage machine), il est
également possible d&rsquo;écrire.. un autre langage ! Cet autre langage sera en
général plus <em>abstrait</em> (plus éloigné donc de la réalité physique de
l&rsquo;ordinateur), ce qui permettra au programmeur d&rsquo;exprimer des idées
computationnelles plus complexes, d&rsquo;une manière plus naturelle et expressive
(C++, Python ou JavaScript sont des exemples de langage de cette catégorie).
Pour mieux comprendre la notion d&rsquo;un langage en tant que <em>programme</em>, on peut
imaginer qu&rsquo;il s&rsquo;agit d&rsquo;une sorte &ldquo;d&rsquo;ordinateur virtuel&rdquo;, implémenté en terme
d&rsquo;un langage moins abstrait (le langage machine). Ce langage de &ldquo;plus haut
niveau&rdquo; (plus abstrait) doit encore une fois traiter avec des instructions et
des valeurs (toujours, ultimement, représentées en termes de bits), mais cette
fois on voit apparaître des représentations plus complexes, pouvant encoder des
structures plus riches et diverses :</p><ul><li>des nombres entiers</li><li>des nombres réels (beaucoup plus complexe à représenter!)</li><li>des chaînes de caractères (strings)</li><li>des listes de nombres</li><li>des listes de mots</li><li>des listes de listes de mots</li><li>des images</li><li>des sons</li><li>etc!</li></ul><h2 id=niveau-de-lapprentissage-automatique-et-des-mathématiques>Niveau de l&rsquo;apprentissage automatique et des mathématiques
<a class=anchor href=#niveau-de-lapprentissage-automatique-et-des-math%c3%a9matiques>#</a></h2><p>L&rsquo;aspect &ldquo;algorithmique&rdquo; d&rsquo;un algorithme d&rsquo;apprentissage automatique réfère au
fait qu&rsquo;on effectue en général une procédure, une séquence d&rsquo;opérations (ou de
transformations) sur des données qui sont essentiellement de nature numérique.
Cette procédure est généralement écrite dans un langage du niveau précédent, par
exemple Python. L&rsquo;aspect mathématique des algorithmes d&rsquo;apprentissage
automatique exige des structures des données et des représentations plus
sophistiquées et performantes. L&rsquo;outil conceptuel le plus souvent utilisé pour
les données d&rsquo;AA est l&rsquo;espace vectoriel, souvent de très haute dimensionnalité
(bien au-delà des trois dimensions dans lesquelles nous vivons quotidiennement).</p><p>Prenons l&rsquo;exemple de l&rsquo;image d&rsquo;une maison. Il est raisonnable à priori de
considérer qu&rsquo;une image est représentée dans un espace à deux dimensions, la
grille 2D de ses pixels :</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/2d_house.png alt></p><p>Pourtant, s&rsquo;il s&rsquo;agissait d&rsquo;une maison dans un jeu vidéo, elle pourrait être
représentée par un modèle vectoriel en trois dimensions (ce qui permettrait de
rendre l&rsquo;environnement dynamique, avec une caméra, à l&rsquo;aide d&rsquo;algèbre linéaire)
:</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/3d_house.png alt></p><p>Mais dans le contexte de l&rsquo;apprentissage automatique, nous allons en fait
considérer un espace beaucoup plus difficile à imaginer et représenter, un
espace multi-dimensionnel avec lequel il y a autant de dimensions que de pixels
:</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/nd_house.png alt></p><p>Si notre image a 1000 X 2000 pixels par exemple, il s&rsquo;agira donc d&rsquo;un espace à
6,000,000 dimensions (1000 x 2000 x 3 couleurs de base pour chaque pixel :
rouge, bleu et vert). Il s&rsquo;agit d&rsquo;un espace absolument énorme, qu&rsquo;il n&rsquo;est pas
possible de se représenter visuellement. Un &ldquo;point&rdquo; dans cet espace représente
une image entière et particulière, correspondant aux valeurs de sa position
relative à chacune des 6,000,000 dimensions. Si on ne modifie qu&rsquo;un seul pixel
de cette image, il s&rsquo;agira en fait d&rsquo;un autre point (donc une autre image),
proche, mais tout de même différent du premier.</p><p>Les images ne sont utilisées qu&rsquo;avec certains types d&rsquo;algorithmes
d&rsquo;apprentissage, mais l&rsquo;idée générale de l&rsquo;espace vectoriel à plusieurs
dimensions, pour représenter des objets ou des concepts, est très importante et
répandue. On pourrait utiliser un tel espace pour représenter les
caractéristiques quantitatives (features) d&rsquo;une maison :</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/nf_house.png alt></p><p>Un tel espace pourrait servir à représenter des données tabulaires de ce genre par exemple :</p><table><thead><tr><th>x1 (prix)</th><th>x2 (année de construction)</th><th>x3 (taille du terrain, m²)</th><th>x4 (surface habitable, m²)</th><th>x5 (nombre de chambres)</th><th>x6 (nombre de salles de bain)</th></tr></thead><tbody><tr><td>420 000</td><td>1995</td><td>600</td><td>180</td><td>4</td><td>2</td></tr><tr><td>350 000</td><td>1980</td><td>500</td><td>150</td><td>3</td><td>1</td></tr><tr><td>580 000</td><td>2010</td><td>720</td><td>220</td><td>5</td><td>3</td></tr><tr><td>310 000</td><td>1972</td><td>450</td><td>130</td><td>3</td><td>1</td></tr><tr><td>760 000</td><td>2020</td><td>850</td><td>260</td><td>6</td><td>3</td></tr><tr><td>490 000</td><td>2005</td><td>640</td><td>200</td><td>4</td><td>2</td></tr><tr><td>270 000</td><td>1965</td><td>400</td><td>110</td><td>2</td><td>1</td></tr><tr><td>690 000</td><td>2018</td><td>780</td><td>240</td><td>5</td><td>2</td></tr><tr><td>330 000</td><td>1988</td><td>520</td><td>145</td><td>3</td><td>1</td></tr><tr><td>815 000</td><td>2022</td><td>900</td><td>280</td><td>6</td><td>4</td></tr></tbody></table><p>Donc même s&rsquo;il s&rsquo;agit d&rsquo;un tableau à deux dimensions, les données qu&rsquo;il contient
sont multidimensionnelles.</p><h3 id=les-gpus>Les GPUs
<a class=anchor href=#les-gpus>#</a></h3><p>Il serait possible d&rsquo;implémenter un espace vectoriel entièrement avec les
primitives offertes au niveau précédent (langage de programmation symbolique)
mais il est maintenant établi que l&rsquo;utilisation de GPUs est plus performante.
Les GPUs sont des puces spéciales qui sont spécialisées dans le calcul numérique
parallèle. Cette technologie a été introduite tout d&rsquo;abord dans le contexte des
jeux vidéos, pour le calcul 3D, mais a trouvé rapidement un usage dans les
applications numériques d&rsquo;apprentissage automatique. Les environnements de
programmation spécialisés en AA (PyTorch et TensorFlow en sont de bons exemples)
permettent à un programme écrit dans un langage symbolique (par exemple Python)
de communiquer directement avec ce matériel spécialisé. Le même calcul,
implémenté sur un CPU au lieu d&rsquo;un GPU, serait beaucoup moins performant.</p><h3 id=retour-vers-les-symboles>Retour vers les symboles
<a class=anchor href=#retour-vers-les-symboles>#</a></h3><p>On comprend mieux maintenant la distinction mentionnée souvent entre l&rsquo;IA au
sens classique, qui manipule des symboles, et l&rsquo;apprentissage automatique, qui
manipule plutôt des valeurs numériques, et dont on dit parfois qu&rsquo;il est
sub-symbolique. Dans un certain sens les deux manipulent des données qui sont
ultimement des valeurs numériques (et même au final des entités physiques, les
bits), mais il y a tout de même un sens clair à distinguer les deux types de
mathématiques sur lesquels sont fondés l&rsquo;IA classique et l&rsquo;AA.</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/schema_repr_donnees.png alt></p><h3 id=les-mots-et-leur-sens>Les mots et leur sens
<a class=anchor href=#les-mots-et-leur-sens>#</a></h3><p>Jusqu’ici, nous avons traité des données numériques ou tabulaires. Mais qu’en est-il du <strong>langage naturel</strong> ?
Les mots portent du sens, mais pour un ordinateur ils doivent d’abord être <strong>convertis en nombres</strong>.
Cette étape, qu’on appelle <strong>représentation vectorielle</strong>, est au cœur du traitement automatique du langage.</p><h4 id=lespace-lexical-vectoriel>L’espace lexical vectoriel
<a class=anchor href=#lespace-lexical-vectoriel>#</a></h4><p>La manière la plus simple de représenter les mots est de construire un <strong>espace lexical</strong> où chaque mot
du vocabulaire correspond à une dimension.
Si le vocabulaire contient \(|V|\) mots, l’espace a \(|V|\) dimensions.</p><ul><li>Par exemple, si le vocabulaire est : {chat, chien, maison, arbre, voiture},
alors l’espace est à 5 dimensions.</li><li>Le mot <em>chat</em> correspond à la première dimension, <em>chien</em> à la deuxième, etc.</li></ul><p>Un mot peut alors être représenté comme un vecteur binaire, par exemple :</p><ul><li><em>chien</em> → (0, 1, 0, 0, 0)</li><li><em>maison</em> → (0, 0, 1, 0, 0)</li></ul><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/word_vector_space.png alt></p><h4 id=encodage-dun-document-sac-de-mots>Encodage d’un document (sac de mots)
<a class=anchor href=#encodage-dun-document-sac-de-mots>#</a></h4><p>Avec cette idée, on peut représenter un <strong>document entier</strong> en regardant quels mots du vocabulaire
y apparaissent. On construit alors un vecteur binaire de longueur \(|V|\) :</p><ul><li>1 si le mot est présent dans le document,</li><li>0 sinon.</li></ul><p>Cette représentation est appelée <strong>sac de mots</strong> (<em>bag of words</em>), car on ne se préoccupe pas
de l’ordre des mots ni de leur contexte, mais uniquement de leur présence/absence.</p><p>Exemple avec notre petit vocabulaire {chat, chien, maison, arbre, voiture} :</p><ul><li>Document : <em>« le chat dort dans la maison »</em></li><li>Vecteur : (1, 0, 1, 0, 0)</li></ul><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/word_vector_space_with_doc.png alt></p><p>Si on visualise ces représentations, chaque document correspond à un point dans
un <strong>hypercube unitaire</strong> de dimension \(|V|\).
Chaque coordonnée vaut 0 ou 1.</p><ul><li>Le sommet (0, 0, 0, 0, 0) correspond à un document vide.</li><li>Le sommet (1, 1, 1, 1, 1) correspond à un document qui contient tous les mots du vocabulaire.</li><li>La distance entre deux vecteurs reflète une certaine <strong>similarité lexicale</strong>
(par exemple, la <a href=https://fr.wikipedia.org/wiki/Distance_de_Hamming>distance de
Hamming</a> compte le nombre
de mots différents).</li></ul><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/word_vector_space_with_hypercube.png alt></p><p>Il n&rsquo;est pas nécessaire de limiter la représentation des mots ou des documents à
cet hypercube par contre. Il y a d&rsquo;autres possibilités :</p><ul><li>Au lieu du critère binaire <em>présence ou absence</em> (0 ou 1), on pourrait utiliser le compte des mots (de 0 à $N$)</li><li>On pourrait aussi utiliser un schéma de pondération plus sophistiqué comme
<a href=https://fr.wikipedia.org/wiki/TF-IDF>TF-IDF</a>, qui assigne une valeur aux
mots proportionnelle à deux critères : (1) leur fréquence dans un document donné
et (2) l&rsquo;inverse de leur fréquence à travers la <strong>totalité</strong> des documents</li></ul><h4 id=limites-du-sac-de-mots>Limites du sac de mots
<a class=anchor href=#limites-du-sac-de-mots>#</a></h4><p>Malgré sa simplicité, cette approche a de sérieuses limites :</p><ul><li><strong>Dimensionnalité énorme</strong> : le vocabulaire d’une langue peut contenir des
dizaines de milliers de mots, ce qui rend l’espace vectoriel gigantesque.</li><li><strong>Vecteurs creux (sparse)</strong> : la plupart des documents n’utilisent qu’une fraction du vocabulaire, donc les vecteurs contiennent surtout des zéros.</li><li><strong>Pas de notion de sens</strong> : le sac de mots ne capture pas que <em>chien</em> et <em>chiot</em> sont liés,
ou que <em>banque</em> peut avoir plusieurs sens.</li><li><strong>Pas de contexte</strong> : l’ordre des mots est perdu, alors que « le chien mord l’homme »
et « l’homme mord le chien » devraient clairement avoir des sens différents.</li></ul><p>Une manière simple avec laquelle on pourrait tenter d&rsquo;atténuer le problème du
manque de contexte serait de considérer l&rsquo;espace de toutes les suites possibles
de <em>deux mots</em>, par exemple. Nous allons explorer concrètement une
représentation de ce type (appelée <em>bigramme</em>) dans le <a href=https://cjauvin.github.io/inf1901-teluq/docs/module4/travail-not%C3%A9-4/>travail noté du
quatrième module</a>. Ceci ferait en
sorte d&rsquo;ajouter un contexte aux mots : le bigramme <code>livre intéressant</code> serait
donc distinct du bigramme <code>livre ennuyant</code>. Le problème cependant serait que la
taille du &ldquo;vocabulaire&rdquo; augmenterait de manière dramatique : $|V|^2$ au lieu de
$|V|$, ce qui ferait également en sorte que la représentation serait encore plus
&ldquo;creuse&rdquo;.</p><h4 id=vers-des-représentations-plus-compactes--les-plongements-lexicaux>Vers des représentations plus compactes : les plongements lexicaux
<a class=anchor href=#vers-des-repr%c3%a9sentations-plus-compactes--les-plongements-lexicaux>#</a></h4><p>Pour dépasser ces limites, on utilise des représentations plus <strong>compactes</strong> et plus <strong>riches</strong> :
les <strong>plongements lexicaux</strong> (<em>word embeddings</em>).</p><ul><li>Les mots ou documents sont projetés dans un espace de <strong>faible dimension</strong> (par exemple 100 ou 512).</li><li>Les coordonnées ne sont plus 0 ou 1, mais des valeurs réelles continues.</li><li>Ces coordonnées sont <strong>apprises automatiquement</strong> par un modèle sur de grandes quantités de textes.</li></ul><p>L’idée clé : deux mots qui apparaissent souvent dans des contextes similaires
auront des vecteurs proches dans cet espace.
Par exemple, <em>roi</em> et <em>reine</em> ou <em>Paris</em> et <em>Londres</em>.</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/word_embedding.png alt></p><h4 id=exemple-intuitif>Exemple intuitif
<a class=anchor href=#exemple-intuitif>#</a></h4><p>Supposons qu’on entraîne un modèle sur un grand corpus.
Il pourrait apprendre que :</p><ul><li><em>roi</em> ≈ (0.51, 0.12, -0.34, …)</li><li><em>reine</em> ≈ (0.49, 0.18, -0.29, …)</li><li><em>homme</em> ≈ (0.44, 0.05, -0.21, …)</li><li><em>femme</em> ≈ (0.43, 0.09, -0.19, …)</li></ul><p>La proximité vectorielle montre que <em>roi</em> est plus proche de <em>reine</em> que de <em>voiture</em>.
Mieux encore, les différences de vecteurs permettent de capturer des <strong>analogies</strong> :</p><ul><li><em>roi</em> - <em>homme</em> + <em>femme</em> ≈ <em>reine</em></li></ul><p>C’est cette capacité à capturer des <strong>relations sémantiques</strong> qui rend les plongements lexicaux si puissants.</p><p><img src=https://cjauvin.github.io/inf1901-teluq/images/module2/word_embedding_words.png alt></p><h4 id=résumé>Résumé
<a class=anchor href=#r%c3%a9sum%c3%a9>#</a></h4><ul><li><strong>Espace lexical vectoriel</strong> : chaque mot correspond à une dimension.</li><li><strong>Sac de mots</strong> : un document est encodé comme un vecteur binaire (présence/absence).</li><li><strong>Hypercube unitaire</strong> : vision géométrique de tous les documents possibles.</li><li><strong>Limites</strong> : espace énorme, vecteurs creux, pas de contexte ni de sens.</li><li><strong>Plongements lexicaux</strong> : espaces compacts et continus où la proximité vectorielle reflète la proximité sémantique.</li></ul><p>Ces représentations sont aujourd’hui la base du traitement du langage naturel,
et elles alimentent directement les modèles modernes comme les réseaux de neurones récurrents, les Transformers et les grands modèles de langage.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/diff%C3%A9rence-avec-x/ class="flex align-center float-left book-icon"><img src=https://cjauvin.github.io/inf1901-teluq/svg/backward.svg alt=Previous title="AA versus X">
<span>AA versus X</span>
</a><a href=https://cjauvin.github.io/inf1901-teluq/docs/module2/mod%C3%A8les/ class="flex align-center float-right book-icon"><span>Qu'est-ce qu'un modèle?</span>
<img src=https://cjauvin.github.io/inf1901-teluq/svg/forward.svg alt=Next title="Qu'est-ce qu'un modèle?"></a></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#niveau-des-bits-physiques-et-mathématiques>Niveau des bits, physiques et mathématiques</a></li><li><a href=#niveau-de-lordinateur-et-de-son-langage>Niveau de l&rsquo;ordinateur et de son langage</a></li><li><a href=#niveau-de-la-programmation-symbolique>Niveau de la programmation symbolique</a></li><li><a href=#niveau-de-lapprentissage-automatique-et-des-mathématiques>Niveau de l&rsquo;apprentissage automatique et des mathématiques</a><ul><li><a href=#les-gpus>Les GPUs</a></li><li><a href=#retour-vers-les-symboles>Retour vers les symboles</a></li><li><a href=#les-mots-et-leur-sens>Les mots et leur sens</a><ul><li><a href=#lespace-lexical-vectoriel>L’espace lexical vectoriel</a></li><li><a href=#encodage-dun-document-sac-de-mots>Encodage d’un document (sac de mots)</a></li><li><a href=#limites-du-sac-de-mots>Limites du sac de mots</a></li><li><a href=#vers-des-représentations-plus-compactes--les-plongements-lexicaux>Vers des représentations plus compactes : les plongements lexicaux</a></li><li><a href=#exemple-intuitif>Exemple intuitif</a></li><li><a href=#résumé>Résumé</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>