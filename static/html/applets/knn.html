<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Démonstration Interactive k-NN (Plus Proches Voisins)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f3f4f6;
            user-select: none; /* Prevent text selection while clicking canvas */
        }
        canvas {
            cursor: default;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .control-panel {
            backdrop-filter: blur(8px);
            background-color: rgba(255, 255, 255, 0.9);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 text-slate-800">

    <div class="max-w-4xl w-full">

        <!-- Main Interface -->
        <div class="bg-white p-2 rounded-xl shadow-xl border border-slate-200 relative overflow-hidden">

            <!-- Canvas Container -->
            <div class="relative flex justify-center bg-slate-50 rounded-lg overflow-hidden">
                <canvas id="knnCanvas"></canvas>

                <!-- Interaction Hint Overlay -->
                <div id="hint" class="absolute top-4 left-4 bg-white/80 px-3 py-1 rounded-full text-xs font-semibold text-slate-500 pointer-events-none border border-slate-200 shadow-sm transition-opacity duration-500">
                    Cliquez sur un point pour voir ses voisins, ou ailleurs pour ajouter un point.
                </div>
            </div>

            <!-- Controls -->
            <div class="mt-4 p-4 bg-slate-100 rounded-lg flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="flex items-center gap-4 w-full md:w-3/4">
                    <div class="flex flex-col w-full gap-2">
                        <div class="flex justify-between items-center">
                            <span class="font-bold text-slate-700">K = <span id="kValueDisplay">3</span></span>
                            <span class="text-xs font-bold uppercase tracking-wider text-slate-500">Paramètre</span>
                        </div>
                        <input type="range" id="kSlider" min="1" max="21" step="2" value="3" class="w-full h-2 bg-slate-300 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                    </div>
                </div>

                <!-- Stats & Actions -->
                <div class="flex items-center gap-3 w-full md:w-auto justify-between md:justify-end">
                    <div class="flex flex-col items-center bg-white border border-slate-200 px-3 py-1 rounded shadow-sm" title="Nombre de points mal classés">
                        <span class="text-xs text-slate-400 font-semibold uppercase">Erreurs</span>
                        <span id="errorCountDisplay" class="font-bold text-red-600">0</span>
                    </div>

                    <button onclick="resetSimulation()" class="px-4 py-2 bg-white border border-slate-300 text-slate-700 rounded-md hover:bg-slate-50 hover:text-indigo-600 transition-colors font-medium text-sm shadow-sm whitespace-nowrap">
                        Régénérer les données
                    </button>
                </div>
            </div>

            <!-- Legend -->
            <div class="flex justify-center gap-8 mt-4 pb-2 text-sm font-medium text-slate-600 flex-wrap">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-red-500 border border-red-700"></div>
                    <span>Classe A (Rouge)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-blue-500 border border-blue-700"></div>
                    <span>Classe B (Bleu)</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full border-2 border-amber-500 bg-transparent"></div>
                    <span>Mal classé</span>
                </div>
                                <div class="flex items-center gap-2">
                    <div class="w-5 h-5 rounded-full border-2 border-dashed border-slate-600 bg-slate-300"></div>
                    <span>Point Ajouté</span>
                </div>
            </div>
        </div>

    </div>

<script>
/**
 * Configuration & State
 */
const canvas = document.getElementById('knnCanvas');
const ctx = canvas.getContext('2d');
const kSlider = document.getElementById('kSlider');
const kValueDisplay = document.getElementById('kValueDisplay');
const errorCountDisplay = document.getElementById('errorCountDisplay');

// Canvas Setup
const WIDTH = 800;
const HEIGHT = 500;
const GRID_SIZE = 8; // Pixel step size for background classification (Higher = faster, Lower = smoother)

// State
let k = 3;
let points = [];
let userPoints = []; // New array for user-added points
let selectedPoint = null;

// Colors
const COLORS = {
    red: { fill: '#EF4444', stroke: '#991B1B', bg: 'rgba(239, 68, 68, 0.15)' },
    blue: { fill: '#3B82F6', stroke: '#1E40AF', bg: 'rgba(59, 130, 246, 0.15)' },
    highlight: '#10B981'
};

/**
 * Initialization
 */
function init() {
    // Set canvas resolution
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Handle responsive CSS size
    canvas.style.width = '100%';
    canvas.style.maxWidth = `${WIDTH}px`;
    canvas.style.height = 'auto';

    generatePoints();

    // Initial Draw
    requestAnimationFrame(drawLoop);
}

/**
 * Data Generation (Gaussian Distribution for Ambiguity)
 */
function generatePoints() {
    points = [];
    userPoints = []; // Clear user points on regeneration
    selectedPoint = null;

    // Helper for Box-Muller transform (Gaussian random)
    const randn_bm = () => {
        let u = 0, v = 0;
        while(u === 0) u = Math.random();
        while(v === 0) v = Math.random();
        return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    };

    // Create Red Points (Center slightly left)
    for (let i = 0; i < 25; i++) {
        points.push({
            x: (WIDTH * 0.35) + randn_bm() * (WIDTH * 0.12),
            y: (HEIGHT * 0.5) + randn_bm() * (HEIGHT * 0.15),
            type: 'red',
            isUserAdded: false
        });
    }

    // Create Blue Points (Center slightly right)
    for (let i = 0; i < 25; i++) {
        points.push({
            x: (WIDTH * 0.65) + randn_bm() * (WIDTH * 0.12),
            y: (HEIGHT * 0.5) + randn_bm() * (HEIGHT * 0.15),
            type: 'blue',
            isUserAdded: false
        });
    }

    // Clamp points to canvas
    points.forEach(p => {
        p.x = Math.max(10, Math.min(WIDTH - 10, p.x));
        p.y = Math.max(10, Math.min(HEIGHT - 10, p.y));
        p.isError = false; // Initialize error state
    });

    drawLoop();
}

/**
 * Logic: k-NN Classification
 */
function getNearestNeighbors(targetX, targetY, k) {
    // Calculate distances to all points
    // NOTE: We only consider the fixed 'points' for classification, not other user points.
    const distances = points.map(p => {
        return {
            point: p,
            dist: Math.sqrt((p.x - targetX) ** 2 + (p.y - targetY) ** 2)
        };
    });

    // Sort by distance
    distances.sort((a, b) => a.dist - b.dist);

    // Return top k
    return distances.slice(0, k);
}

function classify(x, y) {
    const neighbors = getNearestNeighbors(x, y, k);

    let redVotes = 0;
    let blueVotes = 0;

    neighbors.forEach(n => {
        if (n.point.type === 'red') redVotes++;
        else blueVotes++;
    });

    // Simple majority vote
    if (redVotes === blueVotes) {
        // Tie-breaker: random or default to blue (doesn't matter much for viz)
        return Math.random() > 0.5 ? 'red' : 'blue';
    }
    return redVotes > blueVotes ? 'red' : 'blue';
}

/**
 * Error Calculation
 */
function updateErrorCount() {
    let errors = 0;

    // Only calculate errors for the fixed, ground-truth points
    points.forEach(p => {
        // Predict the class of point p using its neighbors (including p itself)
        const predictedType = classify(p.x, p.y);

        // Update the error flag on the point object itself for rendering
        if (predictedType !== p.type) {
            errors++;
            p.isError = true;
        } else {
            p.isError = false;
        }
    });

    errorCountDisplay.innerText = errors;

    // Visual feedback on label
    if (errors === 0) {
        errorCountDisplay.className = "font-bold text-emerald-600";
    } else if (errors < 5) {
        errorCountDisplay.className = "font-bold text-yellow-600";
    } else {
        errorCountDisplay.className = "font-bold text-red-600";
    }
}

/**
 * Rendering
 */
function drawBackground() {
    // To optimize, we draw small rectangles instead of setting every pixel
    for (let x = 0; x < WIDTH; x += GRID_SIZE) {
        for (let y = 0; y < HEIGHT; y += GRID_SIZE) {
            // For background we don't exclude any points
            const type = classify(x + GRID_SIZE/2, y + GRID_SIZE/2);
            ctx.fillStyle = COLORS[type].bg;
            ctx.fillRect(x, y, GRID_SIZE, GRID_SIZE);
        }
    }
}

function drawPoints() {
    // Combine points for rendering loop
    const allPoints = [...points, ...userPoints];

    allPoints.forEach(p => {
        // Draw Error Ring if misclassified (only for fixed points)
        if (!p.isUserAdded && p.isError) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.2)'; // Amber glow
            ctx.fill();
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = '#F59E0B'; // Amber-500 solid ring
            ctx.stroke();
        }

        // Point Style
        ctx.beginPath();
        const radius = p.isUserAdded ? 8 : 6; // User points are slightly larger
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = COLORS[p.type].fill;
        ctx.fill();

        // Border Style
        ctx.lineWidth = p.isUserAdded ? 3 : 1.5; // Thicker border for user points
        ctx.strokeStyle = COLORS[p.type].stroke;

        if (p.isUserAdded) {
            ctx.setLineDash([3, 3]); // Dashed border for user points
                    }

        ctx.stroke();
        ctx.setLineDash([]); // Reset dash
    });
}

function drawSelection() {
    if (!selectedPoint) return;

    // 1. Get Neighbors & Classification
    // We include the point itself now
    const neighbors = getNearestNeighbors(selectedPoint.x, selectedPoint.y, k);

    let redVotes = 0;
    let blueVotes = 0;
    neighbors.forEach(n => {
        if (n.point.type === 'red') redVotes++;
        else blueVotes++;
    });

    let predictedType = redVotes > blueVotes ? 'red' : 'blue';
    if (redVotes === blueVotes) predictedType = 'tie'; // Handle tie visually if needed, or just default

    // 2. Draw Lines to Neighbors (Color coded!)
    neighbors.forEach(n => {
        // Line
        ctx.beginPath();
        ctx.moveTo(selectedPoint.x, selectedPoint.y);
        ctx.lineTo(n.point.x, n.point.y);
        // The line color matches the NEIGHBOR'S color to show their vote
        ctx.strokeStyle = COLORS[n.point.type].fill;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]); // Dashed lines
        ctx.stroke();

        // Highlight Neighbor
        ctx.beginPath();
        ctx.arc(n.point.x, n.point.y, 9, 0, Math.PI * 2);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(n.point.x, n.point.y, 9, 0, Math.PI * 2);
        ctx.strokeStyle = COLORS[n.point.type].stroke;
        ctx.lineWidth = 1;
        ctx.stroke();
    });

    // 3. Draw "Prediction Halo" around Selected Point
    // This ring shows what the algorithm THINKS the point is
    const ringColor = predictedType === 'tie' ? '#94a3b8' : COLORS[predictedType].fill;

    ctx.beginPath();
    ctx.arc(selectedPoint.x, selectedPoint.y, 14, 0, Math.PI * 2);
    ctx.strokeStyle = ringColor;
    ctx.lineWidth = 4;
    ctx.setLineDash([]);
    ctx.stroke();
}


function drawLoop() {
    // 1. Re-classify user points based on current K
        userPoints.forEach(p => {
        p.type = classify(p.x, p.y);
    });

    // 2. Update Stats (for fixed points only)
    updateErrorCount();

    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // 3. Draw Classification Regions
    drawBackground();

    // 4. Draw Connections (if selection active)
    // Drawn BEFORE points so lines appear "under" the dots
    drawSelection();

    // 5. Draw Points
    drawPoints();
}

/**
 * Event Handlers
 */

// Slider Change
kSlider.addEventListener('input', (e) => {
    k = parseInt(e.target.value);
    kValueDisplay.innerText = k;
    drawLoop(); // Re-render with new K
});

// Mouse Move - Update Cursor
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    let isOverPoint = false;

    // Check fixed points
    for (let p of points) {
        if (Math.sqrt((p.x - mouseX) ** 2 + (p.y - mouseY) ** 2) < 20) {
            isOverPoint = true; break;
        }
    }
    // Check user points if not over a fixed point
    if (!isOverPoint) {
        for (let p of userPoints) {
            if (Math.sqrt((p.x - mouseX) ** 2 + (p.y - mouseY) ** 2) < 20) {
                isOverPoint = true; break;
            }
        }
    }

    canvas.style.cursor = isOverPoint ? 'pointer' : 'default';
});

// Canvas Interaction (Click)
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();

    // Calculate scale factors in case CSS resized the canvas
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    let clickedPoint = null;
    let minDist = Infinity;

    // 1. Check if clicked near an existing point (fixed or user-added)
    const allPoints = [...points, ...userPoints];
    allPoints.forEach(p => {
        const dist = Math.sqrt((p.x - mouseX) ** 2 + (p.y - mouseY) ** 2);
        if (dist < 20 && dist < minDist) {
            minDist = dist;
            clickedPoint = p;
        }
    });

    if (clickedPoint) {
        // Select existing point
        selectedPoint = clickedPoint;
    } else {
        // Deselect and ADD a new user point
        selectedPoint = null;

        const newUserPoint = {
            x: mouseX,
            y: mouseY,
            type: classify(mouseX, mouseY), // Classify immediately
            isUserAdded: true
        };
        userPoints.push(newUserPoint);
            }

    document.getElementById('hint').style.opacity = '0'; // Hide hint once user interacts
    drawLoop();
});

// Reset Button
window.resetSimulation = function() {
    generatePoints();
    drawLoop();
};

// Start
init();

</script>
<script src="https://cdn.jsdelivr.net/npm/iframe-resizer/js/iframeResizer.contentWindow.min.js"></script>
</body>
</html>